# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
}
)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
K
# Initialize copula objects
copt <- copula::tCopula(param = 0.5, dim = ncol(unif_dist))  # t-Copula with parameter 0.5
copC <- copula::claytonCopula(2, dim = ncol(unif_dist))      # Clayton copula with delta = 2
copG <- copula::gumbelCopula(2, dim = ncol(unif_dist))       # Gumbel copula with theta = 2
# Define lower and upper bounds for the copula parameters and weights
lower <- c(0.1, 1, -0.9, (2 + .Machine$double.eps), 0, 0, 0)
upper <- c(copC@param.upbnd, copG@param.upbnd, 1, 100, 1, 1, 1)
## Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
# Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- copula::fitCopula(copC, unif_dist, "itau", estimate.variance = TRUE)@estimate # Inversion of Kendall's tau for Clayton
par2 <- copula::fitCopula(copG, unif_dist, "itau", estimate.variance = TRUE)@estimate # Inversion of Kendall's tau for Gumbel
par3 <- copula::fitCopula(copt, unif_dist, "mpl", estimate.variance = FALSE)@estimate # MPL to estimate Degrees of Freedom (DF)
# Initialize weights for copulas (initial guesses = 1/3 each)
par6 <- par5 <- par4 <- 1/3
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = c(par1, par2, par3, par4, par5, par6),
fun = LLCG,
LB = lower,
UB = upper,
copt = copt,
copC = copC,
copG = copG,
U = unif_dist,
eqfun = eqfun,
eqB = c(1)) # RSOLNP
## Saving optimization parameters in a list
cop_param <- opt$pars
# Clayton, t, gumbel, and ctg variates matrix
ctg <- Cc <- Cg <- Ct <- matrix(nrow = K, ncol = ncol(unif_dist))
## Generating copula variates
Cc[, ] <- cop_param[5] * copula::rCopula(n = K,
copula = copula::claytonCopula(param = cop_param[1],
dim = ncol(unif_dist)))
Cg[, ] <- cop_param[6] * copula::rCopula(n = K,
copula = copula::gumbelCopula(param = cop_param[2],
dim = ncol(unif_dist)))
Ct[, ] <- cop_param[7] * copula::rCopula(n = K,
copula = copula::tCopula(param = cop_param[3],
df = cop_param[4],
dim = ncol(unif_dist)))
# Linear combination of copula varieties
ctg <- Cc + Ct + Cg
ctg
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
result <- try({
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
}, silent = TRUE)
if (inherits(result, "try-error")) {
# In case of an error, print a warning message
warning("An error occurred while computing the association measure:",
conditionMessage(result))
}
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
result <- try({
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
}, silent = TRUE)
if (inherits(result, "try-error")) {
# In case of an error, print a warning message
warning("An error occurred while computing the association measure")
}
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure
t1 <- i - We
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
is.infinite(unif_dist)
sum(is.infinite(unif_dist))
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
warning = function(w) {
if (!grepl("L-BFGS-B needs finite values of 'fn'", w$message)) {
# Trata todos os outros avisos normalmente
warning(w)
}
# Ignora o aviso "L-BFGS-B needs finite values of 'fn'"
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
result <- try({
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
}, silent = TRUE)
if (inherits(result, "try-error") && !grepl("L-BFGS-B needs finite values of 'fn'", conditionMessage(result))) {
# Em caso de erro diferente de "L-BFGS-B needs finite values of 'fn'", imprime uma mensagem de aviso
warning("An error occurred while computing the association measure:", conditionMessage(result))
}
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
result <- try({
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
}, silent = TRUE)
if (inherits(result, "try-error") && !grepl("L-BFGS-B needs finite values of 'fn'", toString(result))) {
# Em caso de erro diferente de "L-BFGS-B needs finite values of 'fn'", imprime uma mensagem de aviso
warning("An error occurred while computing the association measure:", toString(result))
}
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
tryCatch(
{
if (Mixture) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K), silent = TRUE)
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K), silent = TRUE)
}
if (inherits(association_measure, "try-error") && !grepl("L-BFGS-B needs finite values of 'fn'", toString(association_measure))) {
# Se ocorrer um erro diferente do específico que queremos ignorar, imprime uma mensagem de aviso
warning("An error occurred while computing the association measure:", toString(association_measure))
} if (Mixture) {
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
tryCatch(
{
if (Mixture) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K), silent = TRUE)
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K), silent = TRUE)
}
if (inherits(association_measure, "try-error") && !grepl("L-BFGS-B needs finite values of 'fn'", toString(association_measure))) {
# Se ocorrer um erro diferente do específico que queremos ignorar, imprime uma mensagem de aviso
warning("An error occurred while computing the association measure:", toString(association_measure))
if (Mixture) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K), silent = TRUE)
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K), silent = TRUE)
}
}
},
error = function(e) {
# Em caso de erro no bloco tryCatch(), imprimir mensagem de erro
warning("An error occurred while computing the association measure:", conditionMessage(e))
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
sum(is.na(unif_dist))
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K))
unif_dist[,1] <- Inf
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K))
association_measure
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
if (Mixture == TRUE) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K))
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K))
}
if (!is.matrix(association_measure)) {
# If association_measure is not a matrix, return NULL
warning("Association measure is not a matrix.")
return(NULL)
}
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
t1 <- i - We
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
if (Mixture == TRUE) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K))
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K))
}
if (!is.matrix(association_measure)) {
# If association_measure is not a matrix, return NULL
warning("Association measure is not a matrix.")
return(NULL)
}
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
max(unif_dist)
sum(is.infinite(unif_dist))
t1 <- i - We
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
unif_dist <- fit_garch$unif_dist
sum(is.infinite(unif_dist))
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
!is.finite(unif_dist)
sum(!is.finite(unif_dist))
max(unif_dist)
min(unif_dist)
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
unif_dist
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
unif_dist <- ifelse(unif_dist < 0.05, 0.05, unif_dist)
unif_dist <- ifelse(unif_dist > 0.95, 0.95, unif_dist)
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
unif_dist <- ifelse(unif_dist < 0.03, 0.03, unif_dist)
unif_dist <- ifelse(unif_dist > 0.97, 0.97, unif_dist)
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
unif_dist <- ifelse(unif_dist < 0.01, 0.01, unif_dist)
unif_dist <- ifelse(unif_dist > 0.99, 0.99, unif_dist)
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
source("portfolio_analysis.R")
mixture_portfolio_2y <- RollingWindowEstimation(returns = returns,
We = 504,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
# Number of cores
cores <- detectCores()
cores
8//4
cores
8%%2
source("portfolio_analysis.R")
# Loading ETF returns
returns <- read_csv("data_directory/etfs_rtn.csv")[-1]
# Number of cores
cores <- detectCores()
# Create a cluster
cl <- makeCluster(cores/2)
mixture_portfolio_2y <- RollingWindowEstimation(returns = returns,
We = 504,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
# setting R project environment
my_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my_dir)
# cleaning variables and graphs
rm(list=ls())
graphics.off()
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(tidyquant)     # Financial data analysis
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
library(PerformanceAnalytics) # Performance metrics
library(xts) # Time series object
library(xtable) # Create LaTex tables
library(ggplot2) # Produce graph
library(parallel) # Do parallel computations
# Importing modules
source("data_preprocessing.R")
source("garch_estimate.R")
source("copula_estimate.R")
source("portfolio_optimization.R")
source("portfolio_analysis.R")
source("performance_metrics.R")
source("exporting_results.R")
# Loading ETF returns
returns <- read_csv("data_directory/etfs_rtn.csv")[-1]
# Number of cores
cores <- detectCores()
# Create a cluster
cl <- makeCluster(cores/2)
mixture_portfolio_2y <- RollingWindowEstimation(returns = returns,
We = 504,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
mixture_portfolio_5y <- RollingWindowEstimation(returns = returns,
We = 1260,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
gaussian_portfolio_1y <- RollingWindowEstimation(returns = returns,
We = 252,
Wt = nrow(returns),
K = 1000,
Mixture = FALSE)
mixture_portfolio_2y %>%
write_csv("results/mixture_portfolio_2y.csv")
mixture_portfolio_5y %>%
write_csv("results/mixture_portfolio_5y.csv")
