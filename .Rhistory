"BBAS3.SA", "ABEV3.SA"),
from="2020-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted/lag(adjusted))) %>%
ungroup() %>%
select(-adjusted) %>%
tidyr::spread(symbol, return) %>%
na.omit()
returns
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="2020-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return) %>%
na.omit()
returns
# creating auxiliary matrices and list
N <- ncol(returns)-1
residuals <- vector("list", nrow(returns)-250)
sigma <- vector("list", nrow(returns)-250)
coef <- vector("list", nrow(returns)-250)
unif_dist <- vector("list", nrow(returns)-250)
ymd_vector <- seq(ymd(paste0(2021, "-01-01")), ymd(paste0(2023, "-01-01")), by = "year")
names_vector <- names(returns)[-1]
# iterating over n assets
for (i in 1:(length(ymd_vector)-1)) {
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1])
}
x
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return) %>%
na.omit()
# creating auxiliary matrices and list
N <- ncol(returns)-1
residuals <- vector("list", nrow(returns)-250)
sigma <- vector("list", nrow(returns)-250)
coef <- vector("list", nrow(returns)-250)
unif_dist <- vector("list", nrow(returns)-250)
ymd_vector <- seq(ymd(paste0(2021, "-01-01")), ymd(paste0(2023, "-01-01")), by = "year")
names_vector <- names(returns)[-1]
# iterating over n assets
for (i in 1:(length(ymd_vector)-1)) {
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1])
}
x
coef <- sigma <- residuals <- vector("list", length(ymd_vector))
coef
sigma
# creating auxiliary matrices and list
N <- ncol(returns)-1
ymd_vector <- seq(ymd(paste0(2021, "-01-01")), ymd(paste0(2023, "-01-01")), by = "year")
names_vector <- names(returns)[-1]
unif_dist <- coef <- sigma <- residuals <- vector("list", length(ymd_vector))
i
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
cbind()
x
j=1
j=3
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j])
x
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j]) %>%
cbind()
x
class(x)
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j]) %>%
as.matrix()
x
class(x)
mod_garch <- try(ugarchspec(variance.model = list(model = "sGARCH",
garch.order = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE)
mod_garch <- try(ugarchspec(variance.model = list(model = "sGARCH",
garch.order = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE)
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
garch_fit
residuals[[i]][[j]] <- garch_fit@fit$residuals
sigma[[i]][[j]] <- garch_fit@fit$sigma
coef[[i]][[j]] <- garch_fit@fit$coef
residuals
j
sigma
coef
unif_dist[[i]][[j]] <- psstd(q = residuals[[i]][[j]]/sigma[[i]][[j]],
nu = coef[[i]][[j]][6],
xi = coef[[i]][[j]][5])
unif_dist
>>>>>>> 1a0b3a55afb89e5b8796065d961f940d4534d272
library(tidyverse)
library(tidyquant)
library(rugarch)
library(fGarch)
library(copula)
library(Rsolnp)
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return) %>%
na.omit()
# creating auxiliary matrices and list
N <- ncol(returns)-1
<<<<<<< HEAD
=======
ymd_vector <- seq(ymd(paste0(2021, "-01-01")), ymd(paste0(2023, "-01-01")), by = "year")
names_vector <- names(returns)[-1]
unif_dist <- coef <- sigma <- residuals <- vector("list", length(ymd_vector))
# iterating over n assets
for (i in 1:(length(ymd_vector)-1)) {
for (j in 1:length(names_vector)) {
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j]) %>%
as.matrix()
mod_garch <- try(ugarchspec(variance.model = list(model = "sGARCH",
garch.order = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE)
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[[i]][[j]] <- garch_fit@fit$residuals
sigma[[i]][[j]] <- garch_fit@fit$sigma
coef[[i]][[j]] <- garch_fit@fit$coef
unif_dist[[i]][[j]] <- psstd(q = residuals[[i]][[j]]/sigma[[i]][[j]],
nu = coef[[i]][[j]][6],
xi = coef[[i]][[j]][5])
#unif[[i]][[j - 1]] = pobs(residuals[[i]][[j-1]]/sigma[[i]][[j-1]])
}
}
unif_dist
# creating auxiliary matrices and list
N <- ncol(returns)-1
ymd_vector <- seq(ymd(paste0(1998, "-01-01")), ymd(paste0(2023, "-01-01")), by = "year")
names_vector <- names(returns)[-1]
unif_dist <- coef <- sigma <- residuals <- vector("list", length(ymd_vector)-1)
# iterating over n assets
for (i in 1:(length(ymd_vector)-1)) {
for (j in 1:length(names_vector)) {
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j]) %>%
as.matrix()
mod_garch <- try(ugarchspec(variance.model = list(model = "sGARCH",
garch.order = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE)
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[[i]][[j]] <- garch_fit@fit$residuals
sigma[[i]][[j]] <- garch_fit@fit$sigma
coef[[i]][[j]] <- garch_fit@fit$coef
unif_dist[[i]][[j]] <- psstd(q = residuals[[i]][[j]]/sigma[[i]][[j]],
nu = coef[[i]][[j]][6],
xi = coef[[i]][[j]][5])
#unif[[i]][[j - 1]] = pobs(residuals[[i]][[j-1]]/sigma[[i]][[j-1]])
}
}
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j]) %>%
as.matrix()
x
returns
ymd_vector <- seq(ymd(paste0(2001, "-01-01")), ymd(paste0(2023, "-01-01")), by = "year")
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted)) %>%
zoo::na.fill(0)) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return)
returns
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
mutate(return = zoo::nafi11(0))
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
na.omit() %>%
select(-adjusted) %>%
spread(symbol, return)
returns
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
na.omit()
returns
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
na.omit() %>%
select(-adjusted)
returns
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return) %>%
zoo:na.fill(0)
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted)) %>%
zoo:na.fill(0)) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return) %>%
zoo:na.fill(0)
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted)) %>%
zoo:na.fill(0)) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return)
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return) %>%
na.omit()
# creating auxiliary matrices and list
N <- ncol(returns)-1
ymd_vector <- seq(ymd(paste0(2001, "-01-01")), ymd(paste0(2023, "-01-01")), by = "year")
names_vector <- names(returns)[-1]
unif_dist <- coef <- sigma <- residuals <- vector("list", length(ymd_vector)-1)
# iterating over n assets
for (i in 1:(length(ymd_vector)-1)) {
for (j in 1:length(names_vector)) {
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j]) %>%
as.matrix()
mod_garch <- try(ugarchspec(variance.model = list(model = "sGARCH",
garch.order = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE)
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[[i]][[j]] <- garch_fit@fit$residuals
sigma[[i]][[j]] <- garch_fit@fit$sigma
coef[[i]][[j]] <- garch_fit@fit$coef
unif_dist[[i]][[j]] <- psstd(q = residuals[[i]][[j]]/sigma[[i]][[j]],
nu = coef[[i]][[j]][6],
xi = coef[[i]][[j]][5])
#unif[[i]][[j - 1]] = pobs(residuals[[i]][[j-1]]/sigma[[i]][[j-1]])
}
}
unif_dist
#negative log likelihood function for estimating copula weights and parameters
LLCG <- function(params, U, copC, copG, copt){
slot(copC, "parameters") <- params[1]    #Initial Clayton parameter provided
slot(copG, "parameters") <- params[2]    #Initial Gumbel parameter provided
slot(copt, "parameters") <- params[3:4]  #Initial t parameters provided (correlation and Degrees of Freedom)
pi1 <- params[5] #weight of Clayton copula
pi2 <- params[6] #weight of Gumbel copula
pi3 <- params[7] #weight of t copula
opt <- log(pi1 * dCopula(U, copC) + pi2 * dCopula(U, copG)
+ pi3 * dCopula(U, copt))  ##loglikelihood function to be optimized
if(any(is.infinite(opt))){            ##esse IF está no Pfaff
opt[which(is.infinite(opt))]<-0
}
-sum(opt)
}
#constrain function so that sum(weights)=1
eqfun <- function(params, U, copC, copG, copt){
z <- params[5]+params[6]+params[7]
return(z)
}
#creating a list to store each period's parameters
cop_param <- vector('list', length(unif_dist))
#initializing copulas object
copt <- tCopula(param = 0.5, dim = N)
copC <- claytonCopula(2, dim = N) # delta= 2
copG <- gumbelCopula(2, dim = N)  # theta= 2
#lower and upper bounds of the parameters and weights for bounded non linear opt.
lower <- c(0.1, 1, -0.9,(2+.Machine$double.eps), 0,0,0)
upper <- c(copC@param.upbnd, copG@param.upbnd, 1,100, 1,1,1) #2+eps so that variance of t copula is defined
for(i in 1:length(unif_dist)){
##pseudo-uniform [0,1] observations for each asset
v<-as.matrix(do.call(cbind, unif_dist[[i]]))
U<-v[,1:(N)]
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, U, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
par2 <- fitCopula(copG, U,"itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Gumbel
par3 <- fitCopula(copt, U,"mpl", estimate.variance = F)@estimate ###mpl para poder estimar tambem DF. Na documentacao diz que nao pode usar 'itau' pois ele n estima DF.
par4 <- 1/3 #initial guesses for weights = 1/3 each
par5 <- 1/3
par6 <- 1/3
##non linear constrained optimization
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=U,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##saving optimization parameters in a list
cop_param[[i]]<-opt$pars
}
library(copula)
install.packages("Matrix")
install.packages("Matrix")
install.packages("Matrix")
install.packages("Matrix")
library(copula)
remove.packages("Matrix")
install.packages("Matrix")
install.packages("Matrix")
library(matrix)
install.packages("00LOCK")
install.packages("00LOCK")
devtools::install_url('https://cran.rstudio.com/bin/windows/contrib/4.2/Matrix_1.5-4.1.zip')
install.packages("Rcmd", dependencies = TRUE)
update.packages("Matrix")
library(copula)
update.packages("copula")
installr::updateR()
library(tidyverse)
library(tidyverse)
library(tidyquant)
library(rugarch)
library(fGarch)
library(copula)
library(Rsolnp)
install.packages("rugarch")
library(rugarch)
install.packages("Matrix")
library(rugarch)
library(copula)
library(Rsolnp)
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return) %>%
na.omit()
# creating auxiliary matrices and list
N <- ncol(returns)-1
>>>>>>> 1a0b3a55afb89e5b8796065d961f940d4534d272
ymd_vector <- seq(ymd(paste0(2001, "-01-01")), ymd(paste0(2023, "-01-01")), by = "year")
names_vector <- names(returns)[-1]
unif_dist <- coef <- sigma <- residuals <- vector("list", length(ymd_vector)-1)
# iterating over n assets
for (i in 1:(length(ymd_vector)-1)) {
for (j in 1:length(names_vector)) {
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j]) %>%
as.matrix()
mod_garch <- try(ugarchspec(variance.model = list(model = "sGARCH",
garch.order = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE)
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[[i]][[j]] <- garch_fit@fit$residuals
sigma[[i]][[j]] <- garch_fit@fit$sigma
coef[[i]][[j]] <- garch_fit@fit$coef
unif_dist[[i]][[j]] <- psstd(q = residuals[[i]][[j]]/sigma[[i]][[j]],
nu = coef[[i]][[j]][6],
xi = coef[[i]][[j]][5])
#unif[[i]][[j - 1]] = pobs(residuals[[i]][[j-1]]/sigma[[i]][[j-1]])
}
}
#negative log likelihood function for estimating copula weights and parameters
LLCG <- function(params, U, copC, copG, copt){
slot(copC, "parameters") <- params[1]    #Initial Clayton parameter provided
slot(copG, "parameters") <- params[2]    #Initial Gumbel parameter provided
slot(copt, "parameters") <- params[3:4]  #Initial t parameters provided (correlation and Degrees of Freedom)
pi1 <- params[5] #weight of Clayton copula
pi2 <- params[6] #weight of Gumbel copula
pi3 <- params[7] #weight of t copula
opt <- log(pi1 * dCopula(U, copC) + pi2 * dCopula(U, copG)
+ pi3 * dCopula(U, copt))  ##loglikelihood function to be optimized
if(any(is.infinite(opt))){            ##esse IF está no Pfaff
opt[which(is.infinite(opt))]<-0
}
-sum(opt)
}
#constrain function so that sum(weights)=1
eqfun <- function(params, U, copC, copG, copt){
z <- params[5]+params[6]+params[7]
return(z)
}
#creating a list to store each period's parameters
cop_param <- vector('list', length(unif_dist))
#initializing copulas object
copt <- tCopula(param = 0.5, dim = N)
copC <- claytonCopula(2, dim = N) # delta= 2
copG <- gumbelCopula(2, dim = N)  # theta= 2
#lower and upper bounds of the parameters and weights for bounded non linear opt.
lower <- c(0.1, 1, -0.9,(2+.Machine$double.eps), 0,0,0)
upper <- c(copC@param.upbnd, copG@param.upbnd, 1,100, 1,1,1) #2+eps so that variance of t copula is defined
for(i in 1:length(unif_dist)){
##pseudo-uniform [0,1] observations for each asset
v<-as.matrix(do.call(cbind, unif_dist[[i]]))
U<-v[,1:(N)]
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, U, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
par2 <- fitCopula(copG, U,"itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Gumbel
par3 <- fitCopula(copt, U,"mpl", estimate.variance = F)@estimate ###mpl para poder estimar tambem DF. Na documentacao diz que nao pode usar 'itau' pois ele n estima DF.
par4 <- 1/3 #initial guesses for weights = 1/3 each
par5 <- 1/3
par6 <- 1/3
##non linear constrained optimization
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=U,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##saving optimization parameters in a list
cop_param[[i]]<-opt$pars
}
cop_param
<<<<<<< HEAD
garch_fit
=======
>>>>>>> 1a0b3a55afb89e5b8796065d961f940d4534d272
