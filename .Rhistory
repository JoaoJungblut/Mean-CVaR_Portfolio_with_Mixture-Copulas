Cg[,]<- cop_param[6]*rCopula(n = K,
copula = gumbelCopula(param = cop_param[2],
dim = N))
Ct[,]<- cop_param[7]*rCopula(n = K,
copula = tCopula(param = cop_param[3],
df = cop_param[4],
dim = N))
#linear combination of them
ctg <- Cc + Ct + Cg
#for each asset, generate copula 'z' dependence structure
rtn_pred <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
for(j in 1:N){
zsim[,j] <- qsstd(ctg[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]) /
sd(qsstd(ctg[,j], nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]))
rtn_t <- as.numeric(returns[(t2-1),(j+1)])
sigma_t <- sigma[K,j]
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alpha1
garch_coef[[j]][4]*(sigma_t)^2) #beta1
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t #mu e ar1
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j]*zsim[1,j]
for(t in 2:K){
sigma_pred[t, j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_pred[(t-1), j])^2 + #alpha1
garch_coef[[j]][4]*(sigma_pred[(t-1), j])^2) #beta1
mean_pred[t, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_pred[(t-1), j] #mu e ar1
rtn_pred[t, j] <- mean_pred[t, j] + sigma_pred[t, j]*zsim[t,j]
}
}
##optimizing portfolio using K simulated return for each assets, for optimization period i
retornofPort <- as.timeSeries(rtn_pred[, 1:N])
frontier1g <- efficientPortfolio(data = retornofPort,
spec = frontierSpec,
constraints = "LongOnly")
cvar_opt[(i-1),1:N] <- getWeights(frontier1g)   #storing resulting weights
# Calculate portfolio returns
portfolio_returns <- as.matrix(returns[(t1+K):(t2+K), names_vector]) %*% t(cvar_opt[(-1),])
portfolio_daily_returns[(t1+K):(t2+K),] <- rowSums(portfolio_returns)
}
library(ggplot2)
# Calcular os retornos acumulados
portfolio_cumulative_returns <- cumsum(portfolio_daily_returns)
# Criar um data frame com os retornos acumulados
df <- data.frame(date = returns$date, cumulative_returns = portfolio_cumulative_returns)
# Criar o gráfico de linha dos retornos acumulados
ggplot(data = df, aes(x = date, y = cumulative_returns)) +
geom_line() +
labs(x = "Data", y = "Retornos Acumulados", title = "Retornos Acumulados do Portfólio")
portfolio_daily_returns
i=2
# Matrix to save sigma forecasts
unif_dist <- garch_pred <- sigma <- residuals <- matrix(nrow = K, ncol = N)
garch_coef <- vector("list", length = N)
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
for (j in 1:length(names_vector)) {
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[,j] <- garch_fit@fit$residuals
sigma[,j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[,j] <- psstd(q = residuals[,j]/sigma[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, unif_dist, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
par2 <- fitCopula(copG, unif_dist,"itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Gumbel
par3 <- fitCopula(copt, unif_dist,"mpl", estimate.variance = F)@estimate ###mpl para poder estimar tambem DF. Na documentacao diz que nao pode usar 'itau' pois ele n estima DF.
##non linear constrained optimization (RSOLNP)
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=unif_dist,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##saving optimization parameters in a list
cop_param <-opt$pars
#clayton, t, gumbel and ctg variates matrix
ctg <- Cc <- Cg <- Ct <- matrix(nrow = K, ncol = N)
##generating copula variates
Cc[,]<- cop_param[5]*rCopula(n = K,
copula = claytonCopula(param = cop_param[1],
dim = N))
Cg[,]<- cop_param[6]*rCopula(n = K,
copula = gumbelCopula(param = cop_param[2],
dim = N))
Ct[,]<- cop_param[7]*rCopula(n = K,
copula = tCopula(param = cop_param[3],
df = cop_param[4],
dim = N))
#linear combination of them
ctg <- Cc + Ct + Cg
#for each asset, generate copula 'z' dependence structure
rtn_pred <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
for(j in 1:N){
zsim[,j] <- qsstd(ctg[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]) /
sd(qsstd(ctg[,j], nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]))
rtn_t <- as.numeric(returns[(t2-1),(j+1)])
sigma_t <- sigma[K,j]
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alpha1
garch_coef[[j]][4]*(sigma_t)^2) #beta1
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t #mu e ar1
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j]*zsim[1,j]
for(t in 2:K){
sigma_pred[t, j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_pred[(t-1), j])^2 + #alpha1
garch_coef[[j]][4]*(sigma_pred[(t-1), j])^2) #beta1
mean_pred[t, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_pred[(t-1), j] #mu e ar1
rtn_pred[t, j] <- mean_pred[t, j] + sigma_pred[t, j]*zsim[t,j]
}
}
##optimizing portfolio using K simulated return for each assets, for optimization period i
retornofPort <- as.timeSeries(rtn_pred[, 1:N])
frontier1g <- efficientPortfolio(data = retornofPort,
spec = frontierSpec,
constraints = "LongOnly")
cvar_opt[(i-1),1:N] <- getWeights(frontier1g)   #storing resulting weights
# Calculate portfolio returns
portfolio_returns <- as.matrix(returns[(t1+K):(t2+K), names_vector]) %*% t(cvar_opt[(-1),])
portfolio_returns
rowSums(portfolio_returns)
t1
t2
portfolio_daily_returns[(t1+K):(t2+K),] <- rowSums(portfolio_returns)
portfolio_daily_returns[(t1+K):(t2+K),]
# iterating over n assets
for (i in 2:length(index_vector)){
# Matrix to save sigma forecasts
unif_dist <- garch_pred <- sigma <- residuals <- matrix(nrow = K, ncol = N)
garch_coef <- vector("list", length = N)
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
for (j in 1:length(names_vector)) {
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[,j] <- garch_fit@fit$residuals
sigma[,j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[,j] <- psstd(q = residuals[,j]/sigma[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, unif_dist, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
par2 <- fitCopula(copG, unif_dist,"itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Gumbel
par3 <- fitCopula(copt, unif_dist,"mpl", estimate.variance = F)@estimate ###mpl para poder estimar tambem DF. Na documentacao diz que nao pode usar 'itau' pois ele n estima DF.
##non linear constrained optimization (RSOLNP)
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=unif_dist,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##saving optimization parameters in a list
cop_param <-opt$pars
#clayton, t, gumbel and ctg variates matrix
ctg <- Cc <- Cg <- Ct <- matrix(nrow = K, ncol = N)
##generating copula variates
Cc[,]<- cop_param[5]*rCopula(n = K,
copula = claytonCopula(param = cop_param[1],
dim = N))
Cg[,]<- cop_param[6]*rCopula(n = K,
copula = gumbelCopula(param = cop_param[2],
dim = N))
Ct[,]<- cop_param[7]*rCopula(n = K,
copula = tCopula(param = cop_param[3],
df = cop_param[4],
dim = N))
#linear combination of them
ctg <- Cc + Ct + Cg
#for each asset, generate copula 'z' dependence structure
rtn_pred <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
for(j in 1:N){
zsim[,j] <- qsstd(ctg[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]) /
sd(qsstd(ctg[,j], nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]))
rtn_t <- as.numeric(returns[(t2-1),(j+1)])
sigma_t <- sigma[K,j]
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alpha1
garch_coef[[j]][4]*(sigma_t)^2) #beta1
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t #mu e ar1
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j]*zsim[1,j]
for(t in 2:K){
sigma_pred[t, j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_pred[(t-1), j])^2 + #alpha1
garch_coef[[j]][4]*(sigma_pred[(t-1), j])^2) #beta1
mean_pred[t, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_pred[(t-1), j] #mu e ar1
rtn_pred[t, j] <- mean_pred[t, j] + sigma_pred[t, j]*zsim[t,j]
}
}
##optimizing portfolio using K simulated return for each assets, for optimization period i
retornofPort <- as.timeSeries(rtn_pred[, 1:N])
frontier1g <- efficientPortfolio(data = retornofPort,
spec = frontierSpec,
constraints = "LongOnly")
cvar_opt[(i-1),1:N] <- getWeights(frontier1g)   #storing resulting weights
# Calculate portfolio returns
portfolio_returns <- as.matrix(returns[(t1+K):(t2+K), names_vector]) %*% t(cvar_opt[(-1),])
portfolio_daily_returns[(t1+K):(t2+K),] <- rowSums(portfolio_returns)
}
portfolio_daily_returns[(t1+K):(t2+K),]
portfolio_daily_returns
portfolio_cumulative_returns <- cumsum(portfolio_daily_returns)
nrow(portfolio_daily_returns)
nrow(returns)
# Criar um data frame com os retornos acumulados
df <- data.frame(date = returns$date, cumulative_returns = portfolio_cumulative_returns)
df
# Criar o gráfico de linha dos retornos acumulados
ggplot(data = df, aes(x = date, y = cumulative_returns)) +
geom_line() +
labs(x = "Data", y = "Retornos Acumulados", title = "Retornos Acumulados do Portfólio")
portfolio_cumulative_returns %>% view()
portfolio_daily_returns[253:300,]
# Calcular os retornos acumulados
portfolio_cumulative_returns <- cumsum(portfolio_daily_returns)*100
# Criar um data frame com os retornos acumulados
df <- data.frame(date = returns$date, cumulative_returns = portfolio_cumulative_returns)
# Criar o gráfico de linha dos retornos acumulados
ggplot(data = df, aes(x = date, y = cumulative_returns)) +
geom_line() +
labs(x = "Data", y = "Retornos Acumulados", title = "Retornos Acumulados do Portfólio")
# Calcular os retornos acumulados
portfolio_cumulative_returns <- cumsum(portfolio_daily_returns)
portfolio_cumulative_returns <- cumsum(returns[,"PETR4.SA"])
# Criar um data frame com os retornos acumulados
df <- data.frame(date = returns$date, cumulative_returns = portfolio_cumulative_returns)
# Criar o gráfico de linha dos retornos acumulados
ggplot(data = df, aes(x = date, y = cumulative_returns)) +
geom_line() +
labs(x = "Data", y = "Retornos Acumulados", title = "Retornos Acumulados do Portfólio")
df
portfolio_cumulative_returns
# Criar um data frame com os retornos acumulados
df <- data.frame(date = returns$date, cumulative_returns = portfolio_cumulative_returns)
df
portfolio_cumulative_returns <- cumsum(cbind(returns[,"PETR4.SA"]))
# Criar um data frame com os retornos acumulados
df <- data.frame(date = returns$date, cumulative_returns = portfolio_cumulative_returns)
# Criar o gráfico de linha dos retornos acumulados
ggplot(data = df, aes(x = date, y = cumulative_returns)) +
geom_line() +
labs(x = "Data", y = "Retornos Acumulados", title = "Retornos Acumulados do Portfólio")
df
# Criar o gráfico de linha dos retornos acumulados
ggplot(data = df, aes(x = date, y = "PETR4.SA")) +
geom_line() +
labs(x = "Data", y = "Retornos Acumulados", title = "Retornos Acumulados do Portfólio")
returns[,"PETR4.SA"]
view(portfolio_cumulative_returns)
# Calcular os retornos acumulados
portfolio_cumulative_returns <- cumsum(portfolio_daily_returns)
# Criar um data frame com os retornos acumulados
df <- data.frame(date = returns$date, cumulative_returns = portfolio_cumulative_returns)
# Criar o gráfico de linha dos retornos acumulados
ggplot(data = df, aes(x = date, y = cumulative_returns)) +
geom_line() +
labs(x = "Data", y = "Retornos Acumulados", title = "Retornos Acumulados do Portfólio")
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(tidyquant)     # Financial data analysis
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
returns <- read_csv("data_directory/log_rtn.csv")
returns
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
K <- 252                 # Window size for GARCH estimation
index_vector <- seq(1, nrow(returns), by = K)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
portfolio_daily_returns <- matrix(nrow = nrow(returns), ncol = 1)  # Matrix to store portfolio returns
portfolio_daily_returns[1:K, ] <- 0  # Initialize the first K rows as zero
# Initialize the GARCH specification
mod_garch <- try(
rugarch::ugarchspec(variance.model = list(model = "sGARCH",
garchOrder = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE
)
# Initialize copula objects
copt <- copula::tCopula(param = 0.5, dim = N)  # t-Copula with parameter 0.5
copC <- copula::claytonCopula(2, dim = N)      # Clayton copula with delta = 2
copG <- copula::gumbelCopula(2, dim = N)       # Gumbel copula with theta = 2
# Define lower and upper bounds for the copula parameters and weights
lower <- c(0.1, 1, -0.9, (2 + .Machine$double.eps), 0, 0, 0)
upper <- c(copC@param.upbnd, copG@param.upbnd, 1, 100, 1, 1, 1)
# Initialize weights for copulas (initial guesses = 1/3 each)
par6 <- par5 <- par4 <- 1/3
# Negative log-likelihood function for estimating copula weights and parameters
LLCG <- function(params, U, copC, copG, copt){
# Set copula parameters
slot(copC, "parameters") <- params[1]    # Initial Clayton parameter
slot(copG, "parameters") <- params[2]    # Initial Gumbel parameter
slot(copt, "parameters") <- params[3:4]  # Initial t parameters (correlation and degrees of freedom)
# Set copula weights
pi1 <- params[5]  # Weight of Clayton copula
pi2 <- params[6]  # Weight of Gumbel copula
pi3 <- params[7]  # Weight of t copula
# Calculate the log-likelihood function to be optimized
opt <- log(pi1 * copula::dCopula(U, copC) + pi2 * copula::dCopula(U, copG) + pi3 * copula::dCopula(U, copt))
# Handle infinite values in the log-likelihood
if(any(is.infinite(opt))){
opt[which(is.infinite(opt))] <- 0
}
# Return the negative sum of the log-likelihood
-sum(opt)
}
# Constrain function to ensure sum(weights) = 1
eqfun <- function(params, U, copC, copG, copt){
z <- params[5] + params[6] + params[7]
return(z)
}
##### Setting up a fPortfolio min CVaR optimization
cvar_opt <- matrix(nrow = length(index_vector) - 1, ncol = N)  # Matrix to store CVaR optimization results
targetReturn <- 0  # Daily target return constraint
frontierSpec <- fPortfolio::portfolioSpec()  # Portfolio specification for optimization
fPortfolio::setType(frontierSpec) <- "CVaR"  # Set portfolio type as CVaR
fPortfolio::setSolver(frontierSpec) <- "solveRglpk.CVAR"  # Use linear programming solver for CVaR optimization
fPortfolio::setAlpha(frontierSpec) <- 0.025  # Set CVaR alpha level as 0.05 (CVaR_0.95)
fPortfolio::setTargetReturn(frontierSpec) <- targetReturn  # Set the daily target return constraint
# Iterating over n assets
for (i in 2:length(index_vector)) {
# Matrix to save sigma forecasts
unif_dist <- garch_pred <- sigma <- residuals <- matrix(nrow = K, ncol = N)
garch_coef <- vector("list", length = N)
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Looping through each asset
for (j in 1:length(names_vector)) {
x <- cbind(returns[t1:t2, (j + 1)])
# Fitting GARCH model
garch_fit <- try(rugarch::ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[, j] <- garch_fit@fit$residuals
sigma[, j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[, j] <- fGarch::psstd(q = residuals[, j] / sigma[, j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
## Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
# Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- copula::fitCopula(copC, unif_dist, "itau", estimate.variance = TRUE)@estimate # Inversion of Kendall's tau for Clayton
par2 <- copula::fitCopula(copG, unif_dist, "itau", estimate.variance = TRUE)@estimate # Inversion of Kendall's tau for Gumbel
par3 <- copula::fitCopula(copt, unif_dist, "mpl", estimate.variance = FALSE)@estimate # MPL to estimate Degrees of Freedom (DF)
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = c(par1, par2, par3, par4, par5, par6),
fun = LLCG,
LB = lower,
UB = upper,
copt = copt,
copC = copC,
copG = copG,
U = unif_dist,
eqfun = eqfun,
eqB = c(1)) # RSOLNP
## Saving optimization parameters in a list
cop_param <- opt$pars
# Clayton, t, gumbel, and ctg variates matrix
ctg <- Cc <- Cg <- Ct <- matrix(nrow = K, ncol = N)
## Generating copula variates
Cc[, ] <- cop_param[5] * copula::rCopula(n = K,
copula = copula::claytonCopula(param = cop_param[1],
dim = N))
Cg[, ] <- cop_param[6] * copula::rCopula(n = K,
copula = copula::gumbelCopula(param = cop_param[2],
dim = N))
Ct[, ] <- cop_param[7] * copula::rCopula(n = K,
copula = copula::tCopula(param = cop_param[3],
df = cop_param[4],
dim = N))
# Linear combination of copula varieties
ctg <- Cc + Ct + Cg
# For each asset, generate copula 'z' dependence structure
rtn_pred <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
for (j in 1:N) {
zsim[, j] <- fGarch::qsstd(ctg[, j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]) /
sd(fGarch::qsstd(ctg[, j], nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]))
rtn_t <- as.numeric(returns[(t2 - 1), (j + 1)])
sigma_t <- sigma[K, j]
sigma_pred[1, j] <- sqrt(garch_coef[[j]][7] +  # omega
garch_coef[[j]][3] * (rtn_t)^2 +  # alpha1
garch_coef[[j]][4] * (sigma_t)^2)  # beta1
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2] * rtn_t  # mu and ar1
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j] * zsim[1, j]
for (t in 2:K) {
sigma_pred[t, j] <- sqrt(garch_coef[[j]][7] +  # omega
garch_coef[[j]][3] * (rtn_pred[(t - 1), j])^2 +  # alpha1
garch_coef[[j]][4] * (sigma_pred[(t - 1), j])^2)  # beta1
mean_pred[t, j] <- garch_coef[[j]][1] + garch_coef[[j]][2] * rtn_pred[(t - 1), j]  # mu and ar1
rtn_pred[t, j] <- mean_pred[t, j] + sigma_pred[t, j] * zsim[t, j]
}
}
## Optimizing portfolio using K simulated returns for each asset, for optimization period i
returnfPort <- as.timeSeries(rtn_pred[, 1:N])
frontier1g <- fPortfolio::efficientPortfolio(data = returnfPort,
spec = frontierSpec,
constraints = "LongOnly")
cvar_opt[(i - 1), 1:N] <- fPortfolio::getWeights(frontier1g)  # Storing resulting weights
# Calculate portfolio returns
t1 <- t1+K
t2 <- min(nrow(returns), t2+K)
portfolio_returns <- as.matrix(returns[t1:t2, names_vector]) %*% t(cvar_opt[(-1), ])
portfolio_daily_returns[t1:t2, ] <- rowSums(portfolio_returns)
}
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
i=2
# Matrix to save sigma forecasts
unif_dist <- garch_pred <- sigma <- residuals <- matrix(nrow = K, ncol = N)
garch_coef <- vector("list", length = N)
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
assets_with_valid_returns
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
ret_matrix_insample
ncol(ret_matrix_insample)
# Looping through each asset
for (j in 1:length(names_vector)) {
x <- cbind(returns[t1:t2, (j + 1)])
# Fitting GARCH model
garch_fit <- try(rugarch::ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[, j] <- garch_fit@fit$residuals
sigma[, j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[, j] <- fGarch::psstd(q = residuals[, j] / sigma[, j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
j=1
# Looping through each asset
for (j in 1:length(names_vector)) {
x <- cbind(ret_matrix_insample[t1:t2, (j + 1)])
# Fitting GARCH model
garch_fit <- try(rugarch::ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[, j] <- garch_fit@fit$residuals
sigma[, j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[, j] <- fGarch::psstd(q = residuals[, j] / sigma[, j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
# Looping through each asset
for (j in 1:length(names_vector)) {
print(j)
x <- cbind(ret_matrix_insample[t1:t2, (j + 1)])
# Fitting GARCH model
garch_fit <- try(rugarch::ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[, j] <- garch_fit@fit$residuals
sigma[, j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[, j] <- fGarch::psstd(q = residuals[, j] / sigma[, j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
# Looping through each asset
for (j in 1:length(names_vector)) {
print(j)
x <- cbind(ret_matrix_insample[t1:t2, j])
# Fitting GARCH model
garch_fit <- try(rugarch::ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[, j] <- garch_fit@fit$residuals
sigma[, j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[, j] <- fGarch::psstd(q = residuals[, j] / sigma[, j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
ret_matrix_insample[,525]
# Looping through each asset
for (j in 1:ncol(ret_matrix_insample)) {
print(j)
x <- cbind(ret_matrix_insample[t1:t2, j])
# Fitting GARCH model
garch_fit <- try(rugarch::ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[, j] <- garch_fit@fit$residuals
sigma[, j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[, j] <- fGarch::psstd(q = residuals[, j] / sigma[, j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
unif_dist
