)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
result <- try({
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
}, silent = TRUE)
if (inherits(result, "try-error") && !grepl("L-BFGS-B needs finite values of 'fn'", conditionMessage(result))) {
# Em caso de erro diferente de "L-BFGS-B needs finite values of 'fn'", imprime uma mensagem de aviso
warning("An error occurred while computing the association measure:", conditionMessage(result))
}
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
result <- try({
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
}, silent = TRUE)
if (inherits(result, "try-error") && !grepl("L-BFGS-B needs finite values of 'fn'", toString(result))) {
# Em caso de erro diferente de "L-BFGS-B needs finite values of 'fn'", imprime uma mensagem de aviso
warning("An error occurred while computing the association measure:", toString(result))
}
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
tryCatch(
{
if (Mixture) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K), silent = TRUE)
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K), silent = TRUE)
}
if (inherits(association_measure, "try-error") && !grepl("L-BFGS-B needs finite values of 'fn'", toString(association_measure))) {
# Se ocorrer um erro diferente do específico que queremos ignorar, imprime uma mensagem de aviso
warning("An error occurred while computing the association measure:", toString(association_measure))
} if (Mixture) {
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
association_measure <- NULL
tryCatch(
{
if (Mixture) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K), silent = TRUE)
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K), silent = TRUE)
}
if (inherits(association_measure, "try-error") && !grepl("L-BFGS-B needs finite values of 'fn'", toString(association_measure))) {
# Se ocorrer um erro diferente do específico que queremos ignorar, imprime uma mensagem de aviso
warning("An error occurred while computing the association measure:", toString(association_measure))
if (Mixture) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K), silent = TRUE)
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K), silent = TRUE)
}
}
},
error = function(e) {
# Em caso de erro no bloco tryCatch(), imprimir mensagem de erro
warning("An error occurred while computing the association measure:", conditionMessage(e))
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
sum(is.na(unif_dist))
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K))
unif_dist[,1] <- Inf
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K))
association_measure
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
if (Mixture == TRUE) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K))
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K))
}
if (!is.matrix(association_measure)) {
# If association_measure is not a matrix, return NULL
warning("Association measure is not a matrix.")
return(NULL)
}
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
t1 <- i - We
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
if (Mixture == TRUE) {
association_measure <- try(OptMixtureCopulas(unif_dist = unif_dist, K = K))
} else {
association_measure <- try(GaussCopula(unif_dist = unif_dist, K = K))
}
if (!is.matrix(association_measure)) {
# If association_measure is not a matrix, return NULL
warning("Association measure is not a matrix.")
return(NULL)
}
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
association_measure
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
max(unif_dist)
sum(is.infinite(unif_dist))
t1 <- i - We
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
unif_dist <- fit_garch$unif_dist
sum(is.infinite(unif_dist))
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
!is.finite(unif_dist)
sum(!is.finite(unif_dist))
max(unif_dist)
min(unif_dist)
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
unif_dist
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
unif_dist <- ifelse(unif_dist < 0.05, 0.05, unif_dist)
unif_dist <- ifelse(unif_dist > 0.95, 0.95, unif_dist)
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
unif_dist <- ifelse(unif_dist < 0.03, 0.03, unif_dist)
unif_dist <- ifelse(unif_dist > 0.97, 0.97, unif_dist)
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
unif_dist <- ifelse(unif_dist < 0.01, 0.01, unif_dist)
unif_dist <- ifelse(unif_dist > 0.99, 0.99, unif_dist)
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
source("portfolio_analysis.R")
mixture_portfolio_2y <- RollingWindowEstimation(returns = returns,
We = 504,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
# Number of cores
cores <- detectCores()
cores
8//4
cores
8%%2
source("portfolio_analysis.R")
# Loading ETF returns
returns <- read_csv("data_directory/etfs_rtn.csv")[-1]
# Number of cores
cores <- detectCores()
# Create a cluster
cl <- makeCluster(cores/2)
mixture_portfolio_2y <- RollingWindowEstimation(returns = returns,
We = 504,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
# setting R project environment
my_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my_dir)
# cleaning variables and graphs
rm(list=ls())
graphics.off()
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(tidyquant)     # Financial data analysis
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
library(PerformanceAnalytics) # Performance metrics
library(xts) # Time series object
library(xtable) # Create LaTex tables
library(ggplot2) # Produce graph
library(parallel) # Do parallel computations
# Importing modules
source("data_preprocessing.R")
source("garch_estimate.R")
source("copula_estimate.R")
source("portfolio_optimization.R")
source("portfolio_analysis.R")
source("performance_metrics.R")
source("exporting_results.R")
# Loading ETF returns
returns <- read_csv("data_directory/etfs_rtn.csv")[-1]
# Number of cores
cores <- detectCores()
# Create a cluster
cl <- makeCluster(cores/2)
mixture_portfolio_2y <- RollingWindowEstimation(returns = returns,
We = 504,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
mixture_portfolio_5y <- RollingWindowEstimation(returns = returns,
We = 1260,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
gaussian_portfolio_1y <- RollingWindowEstimation(returns = returns,
We = 252,
Wt = nrow(returns),
K = 1000,
Mixture = FALSE)
mixture_portfolio_2y %>%
write_csv("results/mixture_portfolio_2y.csv")
mixture_portfolio_5y %>%
write_csv("results/mixture_portfolio_5y.csv")
# setting R project environment
my_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my_dir)
# cleaning variables and graphs
rm(list=ls())
graphics.off()
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(tidyquant)     # Financial data analysis
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
library(PerformanceAnalytics) # Performance metrics
library(xts) # Time series object
library(xtable) # Create LaTex tables
library(ggplot2) # Produce graph
library(parallel) # Do parallel computations
# Importing modules
source("data_preprocessing.R")
source("garch_estimate.R")
source("copula_estimate.R")
source("portfolio_optimization.R")
source("portfolio_analysis.R")
source("performance_metrics.R")
source("exporting_results.R")
# Loading ETF returns
returns <- read_csv("data_directory/etfs_rtn.csv")[-1]
mixture_portfolio_2y <- read_csv("results/mixture_portfolio_2y.csv")
mixture_portfolio_2y
PerformanceAnalytics::charts.PerformanceSummary(xts(mixture_portfolio_2y, order.by = mixture_portfolio_2y$date))
sum(mixture_portfolio_2y)
sum(mixture_portfolio_2y$portfolio_return)
mixture_portfolio_2y <- exp(mixture_portfolio_2y + 0.0003) -1
mixture_portfolio_2y$portfolio_return <- exp(mixture_portfolio_2y$portfolio_return + 0.0003) -1
sum(mixture_portfolio_2y)
sum(mixture_portfolio_2y$portfolio_return)
mixture_portfolio_2y %>%
write_csv("results/mixture_portfolio_2y.csv")
mixture_portfolio_5y <- read_csv("results/mixture_portfolio_5y.csv")
sum(mixture_portfolio_5y$portfolio_return)
mixture_portfolio_5y$portfolio_return <- exp(mixture_portfolio_5y$portfolio_return + 0.0003) - 1
sum(mixture_portfolio_5y$portfolio_return)
mixture_portfolio_5y %>%
write_csv("results/mixture_portfolio_5y.csv")
gaussian_portfolio_1y <- read_csv("results/gaussian_portfolio_1y.csv")
sum(gaussian_portfolio_1y$portfolio_return)
gaussian_portfolio_1y$portfolio_return <- exp(gaussian_portfolio_1y$portfolio_return + 0.0003) - 1
sum(gaussian_portfolio_1y$portfolio_return)
gaussian_portfolio_1y %>%
write_csv("results/gaussian_portfolio_1y.csv")
gaussian_portfolio_2y <- RollingWindowEstimation(returns = returns,
We = 504,
Wt = nrow(returns),
K = 1000,
Mixture = FALSE)
sum(gaussian_portfolio_2y$portfolio_return)
gaussian_portfolio_2y$portfolio_return <- exp(gaussian_portfolio_2y$portfolio_return + 0.0003) - 1
mixture_portfolio_1y <- read_csv("results/mixture_portfolio_1y.csv")
sum(mixture_portfolio_1y)
sum(mixture_portfolio_1y$portfolio_return)
naive_portfolio <- read_csv("results/naive_portfolio.csv")
sum(naive_portfolio$portfolio_return)
# Convert the portfolio_returns matrix to an xts object
mixture_portfolio_1y_xts <- xts::xts(mixture_portfolio_1y[,-1],
order.by = mixture_portfolio_1y$date)
mixture_portfolio_2y_xts <- xts::xts(mixture_portfolio_2y[,-1],
order.by = mixture_portfolio_2y$date)
mixture_portfolio_5y_xts <- xts::xts(mixture_portfolio_5_y[,-1],
order.by = mixture_portfolio_5y$date)
gaussian_portfolio_1y_xts <- xts::xts(gaussian_portfolio_1y[,-1],
order.by = gaussian_portfolio_1y$date)
gaussian_portfolio_2y_xts <- xts::xts(gaussian_portfolio_2y[,-1],
order.by = gaussian_portfolio_2y$date)
gaussian_portfolio_5y_xts <- xts::xts(gaussian_portfolio_5y[,-1],
order.by = gaussian_portfolio_5y$date)
naive_portfolio_xts <- xts::xts(naive_portfolio[(253):Wncol(returns), -1],
order.by = naive_portfolio[(We+1):Wt,]$date)
naive_portfolio_xts <- xts::xts(naive_portfolio[(253):col(returns), -1],
order.by = naive_portfolio[(We+1):Wt,]$date)
gaussian_portfolio_2y %>%
write_csv("results/gaussian_portfolio_2y.csv")
naive_portfolio <- NaiveDiversification(returns)
sum(naive_portfolio$portfolio_return)
naive_portfolio$portfolio_return <- exp(naive_portfolio$portfolio_return) - 1
sum(naive_portfolio$portfolio_return)
source("portfolio_optimization.R")
naive_portfolio <- NaiveDiversification(returns)
sum(naive_portfolio$portfolio_return)
naive_portfolio$portfolio_return <- exp(naive_portfolio$portfolio_return + 0.0003) - 1
naive_portfolio %>%
write_csv("results/naive_portfolio.csv")
# Convert the portfolio_returns matrix to an xts object
mixture_portfolio_1y_xts <- xts::xts(mixture_portfolio_1y[,-1],
order.by = mixture_portfolio_1y$date)
mixture_portfolio_2y_xts <- xts::xts(mixture_portfolio_2y[,-1],
order.by = mixture_portfolio_2y$date)
mixture_portfolio_5y
mixture_portfolio_5y_xts <- xts::xts(mixture_portfolio_5_y[,-1],
order.by = mixture_portfolio_5y$date)
mixture_portfolio_5y_xts <- xts::xts(mixture_portfolio_5y[,-1],
order.by = mixture_portfolio_5y$date)
gaussian_portfolio_1y_xts <- xts::xts(gaussian_portfolio_1y[,-1],
order.by = gaussian_portfolio_1y$date)
gaussian_portfolio_2y_xts <- xts::xts(gaussian_portfolio_2y[,-1],
order.by = gaussian_portfolio_2y$date)
naive_portfolio_xts <- xts::xts(naive_portfolio[(253):ncol(returns), -1],
order.by = naive_portfolio[253:ncol(returns),]$date)
# Compute performance
mixture_portfolio_1y_performance <- ComputePerformance(mixture_portfolio_1y_xts)
mixture_portfolio_2y_performance <- ComputePerformance(mixture_portfolio_2y_xts)
mixture_portfolio_5y_performance <- ComputePerformance(mixture_portfolio_5y_xts)
gaussian_portfolio_1y_performance <- ComputePerformance(gaussian_portfolio_1y_xts)
gaussian_portfolio_2y_performance <- ComputePerformance(gaussian_portfolio_2y_xts)
naive_portfolio_performance <- ComputePerformance(naive_portfolio_xts)
mixture_portfolio_1y_performance
mixture_portfolio_2y_performance
mixture_portfolio_5y_performance
naive_portfolio_performance
merged_portfolio_1y <- merge.xts(mixture_portfolio_1y_xts,
gaussian_portfolio_1y_xts,
naive_portfolio_xts, join = "inner")
merged_portfolio_1y <- merge.xts(mixture_portfolio_1y_xts,
gaussian_portfolio_1y_xts,
naive_portfolio_xts)
merged_portfolio_1y
naive_portfolio_xts <- xts::xts(naive_portfolio[253:ncol(returns), -1],
order.by = naive_portfolio[253:ncol(returns),1])
returns
ifelse(is.na(returns), 0, returns)
nrow(returns)
# Replace NA with 0
returns <- ifelse(is.na(returns), 0, returns)
nrow(returns)
# Loading ETF returns
returns <- read_csv("data_directory/etfs_rtn.csv")[-1]
naive_portfolio %>% view()
merged_portfolio_1y <- merge.xts(mixture_portfolio_1y_xts,
gaussian_portfolio_1y_xts,
naive_portfolio_xts)
merged_portfolio_1y
naive_portfolio
naive_portfolio_xts
naive_portfolio[253:ncol(returns),1]
naive_portfolio_xts <- xts::xts(naive_portfolio[253:ncol(returns), -1],
order.by = (naive_portfolio[253:ncol(returns),1]))
head(naive_portfolio_xts)
naive_date <- naive_portfolio[253:ncol(returns),1]
naive_date
naive_portfolio_xts <- xts::xts(naive_portfolio[253:ncol(returns), -1],
order.by = naive_date)
head(naive_portfolio_xts)
naive_portfolio[253,]
head(naive_date)
naive_portfolio_xts <- xts::xts(naive_portfolio[253:ncol(returns), -1],
order.by = naive_date)
head(naive_portfolio_xts)
