# iterating over n assets
for (i in 1:(length(ymd_vector)-1)) {
for (j in 1:length(names_vector)) {
x <- returns %>%
dplyr::filter(date >= ymd_vector[i] & date < ymd_vector[i+1]) %>%
select(names_vector[j]) %>%
as.matrix()
mod_garch <- try(ugarchspec(variance.model = list(model = "sGARCH",
garch.order = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE)
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[[i]][[j]] <- garch_fit@fit$residuals
sigma[[i]][[j]] <- garch_fit@fit$sigma
coef[[i]][[j]] <- garch_fit@fit$coef
unif_dist[[i]][[j]] <- psstd(q = residuals[[i]][[j]]/sigma[[i]][[j]],
nu = coef[[i]][[j]][6],
xi = coef[[i]][[j]][5])
#unif[[i]][[j - 1]] = pobs(residuals[[i]][[j-1]]/sigma[[i]][[j-1]])
}
}
#negative log likelihood function for estimating copula weights and parameters
LLCG <- function(params, U, copC, copG, copt){
slot(copC, "parameters") <- params[1]    #Initial Clayton parameter provided
slot(copG, "parameters") <- params[2]    #Initial Gumbel parameter provided
slot(copt, "parameters") <- params[3:4]  #Initial t parameters provided (correlation and Degrees of Freedom)
pi1 <- params[5] #weight of Clayton copula
pi2 <- params[6] #weight of Gumbel copula
pi3 <- params[7] #weight of t copula
opt <- log(pi1 * dCopula(U, copC) + pi2 * dCopula(U, copG)
+ pi3 * dCopula(U, copt))  ##loglikelihood function to be optimized
if(any(is.infinite(opt))){            ##esse IF está no Pfaff
opt[which(is.infinite(opt))]<-0
}
-sum(opt)
}
#constrain function so that sum(weights)=1
eqfun <- function(params, U, copC, copG, copt){
z <- params[5]+params[6]+params[7]
return(z)
}
#creating a list to store each period's parameters
cop_param <- vector('list', length(unif_dist))
#initializing copulas object
copt <- tCopula(param = 0.5, dim = N)
copC <- claytonCopula(2, dim = N) # delta= 2
copG <- gumbelCopula(2, dim = N)  # theta= 2
#lower and upper bounds of the parameters and weights for bounded non linear opt.
lower <- c(0.1, 1, -0.9,(2+.Machine$double.eps), 0,0,0)
upper <- c(copC@param.upbnd, copG@param.upbnd, 1,100, 1,1,1) #2+eps so that variance of t copula is defined
for(i in 1:length(unif_dist)){
##pseudo-uniform [0,1] observations for each asset
v<-as.matrix(do.call(cbind, unif_dist[[i]]))
U<-v[,1:(N)]
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, U, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
par2 <- fitCopula(copG, U,"itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Gumbel
par3 <- fitCopula(copt, U,"mpl", estimate.variance = F)@estimate ###mpl para poder estimar tambem DF. Na documentacao diz que nao pode usar 'itau' pois ele n estima DF.
par4 <- 1/3 #initial guesses for weights = 1/3 each
par5 <- 1/3
par6 <- 1/3
##non linear constrained optimization
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=U,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##saving optimization parameters in a list
cop_param[[i]]<-opt$pars
}
cop_param
<<<<<<< HEAD
garch_fit
=======
>>>>>>> 1a0b3a55afb89e5b8796065d961f940d4534d272
library(tidyverse)
library(tidyquant)
library(rugarch)
library(fGarch)
library(copula)
library(Rsolnp)
# importing data and calculating returns
returns <- tq_get(c("PETR4.SA", "VALE3.SA", "ITUB4.SA",
"BBAS3.SA", "ABEV3.SA"),
from="1997-01-01") %>%
select(date, symbol, adjusted) %>%
group_by(symbol) %>%
mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
ungroup() %>%
select(-adjusted) %>%
spread(symbol, return) %>%
na.omit()
# creating auxiliary matrices and list
N <- ncol(returns)-1
K <- 252
index_vector <- seq(1, nrow(returns), by=K)
names_vector <- names(returns)[-1]
garch_pred <- garch_coef <- sigma <- residuals <- matrix(nrow = K, ncol = N)
cop_param <- unif_dist <- matrix(nrow = K, ncol = N)
mod_garch <- try(ugarchspec(variance.model = list(model = "sGARCH",
garch.order = c(1, 1),
variance.targeting = TRUE),
mean.model = list(armaOrder = c(1, 0)),
distribution.model = "sstd"),
silent = TRUE)
for (j in 1:length(names_vector)) {
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[,j] <- garch_fit@fit$residuals
sigma[,j] <- garch_fit@fit$sigma
garch_coef[,j] <- garch_fit@fit$coef
unif_dis[,j] <- psstd(q = residuals[,j]/sigma[,j],
nu = garch_coef[,j][6],
xi = garch_coef[,j][5])
}
i=1
for (j in 1:length(names_vector)) {
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[,j] <- garch_fit@fit$residuals
sigma[,j] <- garch_fit@fit$sigma
garch_coef[,j] <- garch_fit@fit$coef
unif_dis[,j] <- psstd(q = residuals[,j]/sigma[,j],
nu = garch_coef[,j][6],
xi = garch_coef[,j][5])
}
i=2
for (j in 1:length(names_vector)) {
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[,j] <- garch_fit@fit$residuals
sigma[,j] <- garch_fit@fit$sigma
garch_coef[,j] <- garch_fit@fit$coef
unif_dis[,j] <- psstd(q = residuals[,j]/sigma[,j],
nu = garch_coef[,j][6],
xi = garch_coef[,j][5])
}
for (j in 1:length(names_vector)) {
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[,j] <- garch_fit@fit$residuals
sigma[,j] <- garch_fit@fit$sigma
garch_coef[,j] <- garch_fit@fit$coef
unif_dist[,j] <- psstd(q = residuals[,j]/sigma[,j],
nu = garch_coef[,j][6],
xi = garch_coef[,j][5])
}
residuals
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, unif_dist, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
#initializing copulas object
copt <- tCopula(param = 0.5, dim = N)
copC <- claytonCopula(2, dim = N) # delta= 2
copG <- gumbelCopula(2, dim = N)  # theta= 2
#lower and upper bounds of the parameters and weights for bounded non linear opt.
lower <- c(0.1, 1, -0.9,(2+.Machine$double.eps), 0,0,0)
upper <- c(copC@param.upbnd, copG@param.upbnd, 1,100, 1,1,1) #2+eps so that variance of t copula is defined
#initial guesses for weights = 1/3 each
par6 <- par5 <- par4 <- 1/3
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, unif_dist, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
par2 <- fitCopula(copG, unif_dist,"itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Gumbel
par3 <- fitCopula(copt, unif_dist,"mpl", estimate.variance = F)@estimate ###mpl para poder estimar tambem DF. Na documentacao diz que nao pode usar 'itau' pois ele n estima DF.
##non linear constrained optimization (RSOLNP)
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=U,eqfun = eqfun, eqB=c(1)) ####RSOLNP
#negative log likelihood function for estimating copula weights and parameters
LLCG <- function(params, U, copC, copG, copt){
slot(copC, "parameters") <- params[1]    #Initial Clayton parameter provided
slot(copG, "parameters") <- params[2]    #Initial Gumbel parameter provided
slot(copt, "parameters") <- params[3:4]  #Initial t parameters provided (correlation and Degrees of Freedom)
pi1 <- params[5] #weight of Clayton copula
pi2 <- params[6] #weight of Gumbel copula
pi3 <- params[7] #weight of t copula
opt <- log(pi1 * dCopula(U, copC) + pi2 * dCopula(U, copG)
+ pi3 * dCopula(U, copt))  ##loglikelihood function to be optimized
if(any(is.infinite(opt))){            ##esse IF está no Pfaff
opt[which(is.infinite(opt))]<-0
}
-sum(opt)
}
#constrain function so that sum(weights)=1
eqfun <- function(params, U, copC, copG, copt){
z <- params[5]+params[6]+params[7]
return(z)
}
##non linear constrained optimization (RSOLNP)
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=U,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##non linear constrained optimization (RSOLNP)
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=unif_dist,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##saving optimization parameters in a list
cop_param <-opt$pars
cop_param
#clayton, t, gumbel and ctg variates matrix
ctg <- Cc <- Cg <- Ct <- matrix(0, nrow = K, ncol = N)
cop_param
cop_param[[1]]
cop_param[1]
##generating copula variates
Cc[,]<- cop_param[5]*rCopula(n = nsim,
copula = claytonCopula(param = cop_param[1],
dim = N))
##generating copula variates
Cc[,]<- cop_param[5]*rCopula(n = K,
copula = claytonCopula(param = cop_param[1],
dim = N))
Cg[,]<- cop_param[6]*rCopula(n = K,
copula = gumbelCopula(param = cop_param[2],
dim = N))
Ct[,]<- cop_param[7]*rCopula(n = K,
copula = tCopula(param = cop_param[3],
df = cop_param[4],
dim = N))
#clayton, t, gumbel and ctg variates matrix
ctg <- Cc <- Cg <- Ct <- matrix(nrow = K, ncol = N)
##generating copula variates
Cc[,]<- cop_param[5]*rCopula(n = K,
copula = claytonCopula(param = cop_param[1],
dim = N))
Cg[,]<- cop_param[6]*rCopula(n = K,
copula = gumbelCopula(param = cop_param[2],
dim = N))
Ct[,]<- cop_param[7]*rCopula(n = K,
copula = tCopula(param = cop_param[3],
df = cop_param[4],
dim = N))
#linear combination of them
ctg <- Cc + Ct + Cg
garch_coef
garch_coef
garch_coef <- vector("list", length = N)
# Matrix to save sigma forecasts
unif_dist <- garch_pred <- sigma <- residuals <- matrix(nrow = K, ncol = N)
garch_coef <- vector("list", length = N)
for (j in 1:length(names_vector)) {
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[,j] <- garch_fit@fit$residuals
sigma[,j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[,j] <- psstd(q = residuals[,j]/sigma[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
garch_coef
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, unif_dist, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
par2 <- fitCopula(copG, unif_dist,"itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Gumbel
par3 <- fitCopula(copt, unif_dist,"mpl", estimate.variance = F)@estimate ###mpl para poder estimar tambem DF. Na documentacao diz que nao pode usar 'itau' pois ele n estima DF.
##non linear constrained optimization (RSOLNP)
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=unif_dist,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##saving optimization parameters in a list
cop_param <-opt$pars
#clayton, t, gumbel and ctg variates matrix
ctg <- Cc <- Cg <- Ct <- matrix(nrow = K, ncol = N)
##generating copula variates
Cc[,]<- cop_param[5]*rCopula(n = K,
copula = claytonCopula(param = cop_param[1],
dim = N))
Cg[,]<- cop_param[6]*rCopula(n = K,
copula = gumbelCopula(param = cop_param[2],
dim = N))
cop_param
Ct[,]<- cop_param[7]*rCopula(n = K,
copula = tCopula(param = cop_param[3],
df = cop_param[4],
dim = N))
#linear combination of them
ctg <- Cc + Ct + Cg
#for each asset, generate copula 'z' dependence strucutre
zsim <- matrix(nrow = K, ncol = N)
#for each asset, generate copula 'z' dependence strucutre
zsim <- matrix(nrow = K, ncol = N)
for(j in 1:N){
zsim[,j] <- qsstd(ctg[,j],
nu = garch_coef[[j]][[6]],
xi = garch_coef[[j]][[5]]) /
sd(qsstd(ctg[,j], nu = garch_coef[[j]][[6]],
xi = garch_coef[[j]][[5]]))
}
zsim
garch_coef
x <- last(cbind(returns[t1:t2,(j+1)]))
x
sigma_t <- last(sigma[,j])
sigma
sigma_t <- sigma[t2,j]
sigma
sigma_t
rtn_t <- cbind(returns[(t2-1),(j+1)])
rtn_t
rtn_t <- returns[(t2-1),(j+1)]
rtn_t
rtn_t <- as.numeric(returns[(t2-1),(j+1)])
rtn_t
garch_coef
garch_coef[[j]][7]
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alfa
garch_coef[[j]][4]*(sigma_t)^2) #beta
#for each asset, generate copula 'z' dependence structure
rtn_sim <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alfa
garch_coef[[j]][4]*(sigma_t)^2) #beta
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t
sigma_pred
rtn_pred[1, j] <- mean_pred + sigma_pred*zsim[1,j]
#for each asset, generate copula 'z' dependence structure
rtn_pred <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alfa
garch_coef[[j]][4]*(sigma_t)^2) #beta
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t #mu e ar1
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j]*zsim[1,j]
rtn_pred
sigma_pred
mean_pred[1,j]
zsim[1,j]
zsim[,j] <- qsstd(ctg[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]) /
sd(qsstd(ctg[,j], nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]))
zsim[1,j]
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j]*zsim[1,j]
rtn_pred[1, j]
#for each asset, generate copula 'z' dependence structure
rtn_pred <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
for(j in 1:N){
zsim[,j] <- qsstd(ctg[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]) /
sd(qsstd(ctg[,j], nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]))
rtn_t <- as.numeric(returns[(t2-1),(j+1)])
sigma_t <- sigma[K,j]
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alfa
garch_coef[[j]][4]*(sigma_t)^2) #beta
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t #mu e ar1
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j]*zsim[1,j]
for(t in 2:K){
sigma_pred[t, j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][2]*(rtn_t)^2 + #alfa
garch_coef[[j]][3]*(sigma_t)^2) #beta
mean_pred[t, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t #mu e ar1
rtn_pred[t, j] <- mean_pred[t, j] + sigma_pred[t, j]*zsim[t,j]
}
}
rtn_pred
sigma_pred
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alfa
garch_coef[[j]][4]*(sigma_t)^2)
sigma_pred[1,j]
mean_pred
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t
mean_pred
mean_pred[1, j]
t=2
#for each asset, generate copula 'z' dependence structure
rtn_pred <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
for(j in 1:N){
zsim[,j] <- qsstd(ctg[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]) /
sd(qsstd(ctg[,j], nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]))
rtn_t <- as.numeric(returns[(t2-1),(j+1)])
sigma_t <- sigma[K,j]
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alfa
garch_coef[[j]][4]*(sigma_t)^2) #beta
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t #mu e ar1
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j]*zsim[1,j]
for(t in 2:K){
sigma_pred[t, j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][2]*(rtn_pred[(t-1), j])^2 + #alfa
garch_coef[[j]][3]*(sigma_pred[(t-1), j])^2) #beta
mean_pred[t, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_pred[(t-1), j] #mu e ar1
rtn_pred[t, j] <- mean_pred[t, j] + sigma_pred[t, j]*zsim[t,j]
}
}
rtn_pred
mean_pred
sigma_pred
# iterating over n assets
for (i in 2:length(index_vector)) {
# Matrix to save sigma forecasts
sigma_pred <- matrix(nrow = K, ncol = N)
for (j in 1:length(names_vector)) {
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[[i-1]][[j]] <- garch_fit@fit$residuals
sigma[[i-1]][[j]] <- garch_fit@fit$sigma
garch_coef[[i-1]][[j]] <- garch_fit@fit$coef
unif_dist[[i-1]][[j]] <- psstd(q = residuals[[i]][[j]]/sigma[[i]][[j]],
nu = garch_coef[[i]][[j]][6],
xi = garch_coef[[i]][[j]][5])
# Predicting return for t+1 in a rolling window
for(t in t1:t2){
x <- cbind(returns[t:(t2+(t-t1)),(j+1)])
sigma_pred[(t-t1+1),j] <- sigma(try(ugarchforecast(mod_garch, data = x, n.ahead = 1)))
}
}
}
# iterating over n assets
for (i in 2:length(index_vector)) {
# Matrix to save sigma forecasts
unif_dist <- garch_pred <- sigma <- residuals <- matrix(nrow = K, ncol = N)
garch_coef <- vector("list", length = N)
for (j in 1:length(names_vector)) {
t1 <- index_vector[i-1]
t2 <- index_vector[i]-1
x <- cbind(returns[t1:t2,(j+1)])
garch_fit <- try(ugarchfit(mod_garch, data = x, solver = "hybrid"),
silent = TRUE)
residuals[,j] <- garch_fit@fit$residuals
sigma[,j] <- garch_fit@fit$sigma
garch_coef[[j]] <- garch_fit@fit$coef
unif_dist[,j] <- psstd(q = residuals[,j]/sigma[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5])
}
##Creating elliptical copula objects and estimating "initial guesses" for each copula parameter.
#Then, we maximize loglikelihood of the linear combination of the three copulas
par1 <- fitCopula(copC, unif_dist, "itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Clayton
par2 <- fitCopula(copG, unif_dist,"itau", estimate.variance = T)@estimate #inversion of Kendall's tau for Gumbel
par3 <- fitCopula(copt, unif_dist,"mpl", estimate.variance = F)@estimate ###mpl para poder estimar tambem DF. Na documentacao diz que nao pode usar 'itau' pois ele n estima DF.
##non linear constrained optimization (RSOLNP)
opt <- solnp(pars = c(par1,par2,par3,par4,par5,par6),
fun = LLCG, LB = lower, UB = upper,
copt=copt,copC = copC, copG = copG,
U=unif_dist,eqfun = eqfun, eqB=c(1)) ####RSOLNP
##saving optimization parameters in a list
cop_param <-opt$pars
#clayton, t, gumbel and ctg variates matrix
ctg <- Cc <- Cg <- Ct <- matrix(nrow = K, ncol = N)
##generating copula variates
Cc[,]<- cop_param[5]*rCopula(n = K,
copula = claytonCopula(param = cop_param[1],
dim = N))
Cg[,]<- cop_param[6]*rCopula(n = K,
copula = gumbelCopula(param = cop_param[2],
dim = N))
Ct[,]<- cop_param[7]*rCopula(n = K,
copula = tCopula(param = cop_param[3],
df = cop_param[4],
dim = N))
#linear combination of them
ctg <- Cc + Ct + Cg
#for each asset, generate copula 'z' dependence structure
rtn_pred <- mean_pred <- sigma_pred <- zsim <- matrix(nrow = K, ncol = N)
for(j in 1:N){
zsim[,j] <- qsstd(ctg[,j],
nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]) /
sd(qsstd(ctg[,j], nu = garch_coef[[j]][6],
xi = garch_coef[[j]][5]))
rtn_t <- as.numeric(returns[(t2-1),(j+1)])
sigma_t <- sigma[K,j]
sigma_pred[1,j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][3]*(rtn_t)^2 + #alpha1
garch_coef[[j]][4]*(sigma_t)^2) #beta1
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_t #mu e ar1
rtn_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j]*zsim[1,j]
for(t in 2:K){
sigma_pred[t, j] <- sqrt(garch_coef[[j]][7] + #omega
garch_coef[[j]][2]*(rtn_pred[(t-1), j])^2 + #alpha1
garch_coef[[j]][3]*(sigma_pred[(t-1), j])^2) #beta1
mean_pred[t, j] <- garch_coef[[j]][1] + garch_coef[[j]][2]*rtn_pred[(t-1), j] #mu e ar1
rtn_pred[t, j] <- mean_pred[t, j] + sigma_pred[t, j]*zsim[t,j]
}
}
}
rtn_pred
