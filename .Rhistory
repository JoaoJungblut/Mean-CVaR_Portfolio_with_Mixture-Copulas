dCop[,i] <- pi*copula::dCopula(U, copJ)
next
}
}
for(i in length(combination)){
# Calculate the log-likelihood function to be optimized
if ("Clayton" %in% names(combination)) {
dCop[,i] <- pi*copula::dCopula(U, copC)
next
}
if ("Gumbel" %in% names(combination)) {
dCop[,i] <- pi*copula::dCopula(U, copG)
next
}
if ("t" %in% names(combination)) {
dCop[,i] <- pi*copula::dCopula(U, copT)
next
}
if ("Gaussian" %in% names(combination)) {
dCop[,i] <- pi*copula::dCopula(U, copN)
next
}
if ("Frank" %in% names(combination)) {
dCop[,i] <- pi*copula::dCopula(U, copF)
next
}
if ("Joe" %in% names(combination)) {
dCop[,i] <- pi*copula::dCopula(U, copJ)
next
}
}
opt <- log(rowSums(dCop))
opt
dCop
# Calculate the log-likelihood function to be optimized
dCop <- matrix(nrow = nrow(U), ncol = length(combination))
colnames(dCop) <- names(combination)
for (i in seq_along(combination)) {
if ("Clayton" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copC)
} else if ("Gumbel" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copG)
} else if ("t" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copT)
} else if ("Gaussian" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copN)
} else if ("Frank" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copF)
} else if ("Joe" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copJ)
}
}
opt <- log(rowSums(dCop))
opt
# Handle infinite values in the log-likelihood
if(any(is.infinite(opt))){
opt[which(is.infinite(opt))] <- 0
}
# Return the negative sum of the log-likelihood
-sum(opt)
# Create an empty list with the desired names
params <- list("Clayton" = NULL,
"Gumbel" = NULL,
"t" = NULL,
"Gaussian" = NULL,
"Frank" = NULL,
"Joe" = NULL)
# Add non-null parameters
params[["Clayton"]] <- paramC
params[["Gumbel"]] <- paramG
params[["t"]] <- paramT
LLCG <- function(params, U, copC, copG, copt){
# LLCG: Negative log-likelihood function for estimating copula weights and parameters.
# Inputs:
#   params: A numeric vector containing the initial values for copula parameters and weights.
#   U: A matrix containing the uniform (0 to 1) marginals of the data for each copula.
#   copC: A copula object (Clayton copula) with initial parameters to be estimated.
#   copG: A copula object (Gumbel copula) with initial parameters to be estimated.
#   copt: A copula object (t copula) with initial parameters to be estimated.
# Output:
#   The negative log-likelihood value to be optimized for estimating copula parameters and weights.
# Filter non-null values
combination <- Filter(negate(is.null), params)
if ("Clayton" %in% names(combination)) {
slot(copC, "parameters") <- combination$Clayton
}
if ("Gumbel" %in% names(combination)) {
slot(copG, "parameters") <- combination$Gumbel
}
if ("t" %in% names(combination)) {
slot(copT, "parameters") <- combination$t
}
if ("Gaussian" %in% names(combination)) {
slot(copN, "parameters") <- combination$Gaussian
}
if ("Frank" %in% names(combination)) {
slot(copF, "parameters") <- combination$Frank
}
if ("Joe" %in% names(combination)) {
slot(copJ, "parameters") <- combination$Joe
}
# Set copula weights
pi <- 1/length(combination)
# Calculate the log-likelihood function to be optimized
dCop <- matrix(nrow = nrow(U), ncol = length(combination))
colnames(dCop) <- names(combination)
for (i in seq_along(combination)) {
if ("Clayton" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copC)
} else if ("Gumbel" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copG)
} else if ("t" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copT)
} else if ("Gaussian" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copN)
} else if ("Frank" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copF)
} else if ("Joe" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copJ)
}
}
opt <- log(rowSums(dCop))
# Handle infinite values in the log-likelihood
if(any(is.infinite(opt))){
opt[which(is.infinite(opt))] <- 0
}
# Return the negative sum of the log-likelihood
-sum(opt)
}
eqfun <- function(params, U){
# eqfun: Constrain function to ensure sum of weights = 1.
# Inputs:
#   params: A numeric vector containing the values of copula weights to be constrained.
#   U: A matrix containing the uniform (0 to 1) marginals of the data for each copula.
# Output:
#   The sum of the copula weights (pi1, pi2, pi3) to be constrained.
# Filter non-null values
combination <- Filter(negate(is.null), params)
pi <- 1 / length(combination)
z <- length(combination) * pi
return(z)
}
combination <- unlist(Filter(negate(is.null), params))
combination
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = combination,
fun = LLCG,
LB = lower,
UB = upper,
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
lower
params <- c(combination, pi, pi, pi)
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = params,
fun = LLCG,
LB = lower,
UB = upper,
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
params
# Create an empty list with the desired names
params <- list("Clayton" = NULL,
"Gumbel" = NULL,
"t" = NULL,
"Gaussian" = NULL,
"Frank" = NULL,
"Joe" = NULL)
# Add non-null parameters
params[["Clayton"]] <- paramC
params[["Gumbel"]] <- paramG
params[["t"]] <- paramT
params[["Gaussian"]] <- paramN
params[["Frank"]] <- paramF
params[["Joe"]] <- paramJ
# Create an empty list with the desired names
params <- list("Clayton" = NULL,
"Gumbel" = NULL,
"t" = NULL,
"Gaussian" = NULL,
"Frank" = NULL,
"Joe" = NULL)
# Add non-null parameters
params[["Clayton"]] <- paramC
params[["Gumbel"]] <- paramG
params[["t"]] <- paramT
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = params,
fun = LLCG,
LB = lower,
UB = upper,
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
combination <- Filter(negate(is.null), params)
combination
combination <- c(combination, rep(pi, length(combination)))
combination
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = params,
fun = LLCG,
LB = lower,
UB = upper,
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
lower
combination
# Initialize lower e upper bounds
lower <- list()
upper <- list()
for (copula_name in names(combination)) {
if (copula_name == "Clayton") {
lower$copula_name <- copC@param.lowbnd
upper$copula_name <- copC@param.upbnd
} else if (copula_name == "Gumbel") {
lower$copula_name <- copG@param.lowbnd
upper$copula_name <- copG@param.upbnd
} else if (copula_name == "t") {
lower$copula_name <- copT@param.lowbnd
upper$copula_name <- copT@param.upbnd
} else if (copula_name == "Gaussian") {
lower$copula_name <- copN@param.lowbnd
upper$copula_name <- copN@param.upbnd
} else if (copula_name == "Frank") {
lower$copula_name <- copF@param.lowbnd
upper$copula_name <- copF@param.upbnd
} else if (copula_name == "Joe") {
lower$copula_name <- copJ@param.lowbnd
upper$copula_name <- copJ@param.upbnd
}
}
lower
# Initialize lower e upper bounds
lower <- list()
upper <- list()
for (i in seq_along(combination)) {
if ("Clayton" %in% names(combination)) {
lower$copula_name <- copC@param.lowbnd
upper$copula_name <- copC@param.upbnd
} else if ("Gumbel" %in% names(combination)) {
lower$copula_name <- copG@param.lowbnd
upper$copula_name <- copG@param.upbnd
} else if ("t" %in% names(combination)) {
lower$copula_name <- copT@param.lowbnd
upper$copula_name <- copT@param.upbnd
} else if ("Gaussian" %in% names(combination)) {
lower$copula_name <- copN@param.lowbnd
upper$copula_name <- copN@param.upbnd
} else if ("Frank" %in% names(combination)) {
lower$copula_name <- copF@param.lowbnd
upper$copula_name <- copF@param.upbnd
} else if ("Joe" %in% names(combination)) {
lower$copula_name <- copJ@param.lowbnd
upper$copula_name <- copJ@param.upbnd
}
}
LOWER
lower
# Initialize lower e upper bounds
lower <- list()
lower
# Initialize lower e upper bounds
lower <- list()
upper <- list()
if ("Clayton" %in% names(combination)) {
lower$"Clayton" <- copC@param.lowbnd
upper$"Clayton" <- copC@param.upbnd
}
if ("Gumbel" %in% names(combination)) {
lower$"Gumbel" <- copG@param.lowbnd
upper$"Gumbel" <- copG@param.upbnd
}
if ("t" %in% names(combination)) {
lower$"t" <- copT@param.lowbnd
upper$"t" <- copT@param.upbnd
}
if ("Gaussian" %in% names(combination)) {
lower$"Gaussian" <- copN@param.lowbnd
upper$"Gaussian" <- copN@param.upbnd
}
if ("Frank" %in% names(combination)) {
lower$"Frank" <- copF@param.lowbnd
upper$"Frank" <- copF@param.upbnd
}
if ("Joe" %in% names(combination)) {
lower$"Joe" <- copJ@param.lowbnd
upper$"Joe" <- copJ@param.upbnd
}
lower
combination
combination <- Filter(negate(is.null), params)
combination
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = params,
fun = LLCG,
LB = lower,
UB = upper,
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = combination,
fun = LLCG,
LB = lower,
UB = upper,
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
upper
.Machine$double.eps
(2 + .Machine$double.eps)
# Define lower and upper bounds for the copula parameters and weights
lower <- c(0.1, 1, -0.9, (2 + .Machine$double.eps), 0, 0, 0)
upper <- c(copC@param.upbnd, copG@param.upbnd, 1, 100, 1, 1, 1)
# Initialize lower e upper bounds
lower <- list()
upper <- list()
if ("Clayton" %in% names(combination)) {
lower$"Clayton" <- 0.1
upper$"Clayton" <- copC@param.upbnd
}
if ("Gumbel" %in% names(combination)) {
lower$"Gumbel" <- 1
upper$"Gumbel" <- copG@param.upbnd
}
if ("t" %in% names(combination)) {
lower$"t" <- c(-0.9, (2 + .Machine$double.eps))
upper$"t" <- c(1, 100)
}
if ("Gaussian" %in% names(combination)) {
lower$"Gaussian" <- copN@param.lowbnd
upper$"Gaussian" <- copN@param.upbnd
}
if ("Frank" %in% names(combination)) {
lower$"Frank" <- copF@param.lowbnd
upper$"Frank" <- copF@param.upbnd
}
if ("Joe" %in% names(combination)) {
lower$"Joe" <- copJ@param.lowbnd
upper$"Joe" <- copJ@param.upbnd
}
lower
upper
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = combination,
fun = LLCG,
LB = lower,
UB = upper,
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = unlist(combination),
fun = LLCG,
LB = unlist(lower),
UB = unlist(upper),
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
eqfun <- function(params, U){
# eqfun: Constrain function to ensure sum of weights = 1.
# Inputs:
#   params: A numeric vector containing the values of copula weights to be constrained.
#   U: A matrix containing the uniform (0 to 1) marginals of the data for each copula.
# Output:
#   The sum of the copula weights (pi1, pi2, pi3) to be constrained.
# Filter non-null values
params = list(params)
combination <- Filter(negate(is.null), params)
pi <- 1 / length(combination)
z <- length(combination) * pi
return(z)
}
LLCG <- function(params, U, copC, copG, copt){
# LLCG: Negative log-likelihood function for estimating copula weights and parameters.
# Inputs:
#   params: A numeric vector containing the initial values for copula parameters and weights.
#   U: A matrix containing the uniform (0 to 1) marginals of the data for each copula.
#   copC: A copula object (Clayton copula) with initial parameters to be estimated.
#   copG: A copula object (Gumbel copula) with initial parameters to be estimated.
#   copt: A copula object (t copula) with initial parameters to be estimated.
# Output:
#   The negative log-likelihood value to be optimized for estimating copula parameters and weights.
# Filter non-null values
params = list(params)
combination <- Filter(negate(is.null), params)
if ("Clayton" %in% names(combination)) {
slot(copC, "parameters") <- combination$Clayton
}
if ("Gumbel" %in% names(combination)) {
slot(copG, "parameters") <- combination$Gumbel
}
if ("t" %in% names(combination)) {
slot(copT, "parameters") <- combination$t
}
if ("Gaussian" %in% names(combination)) {
slot(copN, "parameters") <- combination$Gaussian
}
if ("Frank" %in% names(combination)) {
slot(copF, "parameters") <- combination$Frank
}
if ("Joe" %in% names(combination)) {
slot(copJ, "parameters") <- combination$Joe
}
# Set copula weights
pi <- 1/length(combination)
# Calculate the log-likelihood function to be optimized
dCop <- matrix(nrow = nrow(U), ncol = length(combination))
colnames(dCop) <- names(combination)
for (i in seq_along(combination)) {
if ("Clayton" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copC)
} else if ("Gumbel" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copG)
} else if ("t" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copT)
} else if ("Gaussian" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copN)
} else if ("Frank" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copF)
} else if ("Joe" %in% names(combination)) {
dCop[, i] <- pi * copula::dCopula(U, copJ)
}
}
opt <- log(rowSums(dCop))
# Handle infinite values in the log-likelihood
if(any(is.infinite(opt))){
opt[which(is.infinite(opt))] <- 0
}
# Return the negative sum of the log-likelihood
-sum(opt)
}
eqfun <- function(params, U){
# eqfun: Constrain function to ensure sum of weights = 1.
# Inputs:
#   params: A numeric vector containing the values of copula weights to be constrained.
#   U: A matrix containing the uniform (0 to 1) marginals of the data for each copula.
# Output:
#   The sum of the copula weights (pi1, pi2, pi3) to be constrained.
# Filter non-null values
params = list(params)
combination <- Filter(negate(is.null), params)
pi <- 1 / length(combination)
z <- length(combination) * pi
return(z)
}
combination <- Filter(negate(is.null), params)
# Initialize lower e upper bounds
lower <- list()
upper <- list()
if ("Clayton" %in% names(combination)) {
lower$"Clayton" <- 0.1
upper$"Clayton" <- copC@param.upbnd
}
if ("Gumbel" %in% names(combination)) {
lower$"Gumbel" <- 1
upper$"Gumbel" <- copG@param.upbnd
}
if ("t" %in% names(combination)) {
lower$"t" <- c(-0.9, (2 + .Machine$double.eps))
upper$"t" <- c(1, 100)
}
if ("Gaussian" %in% names(combination)) {
lower$"Gaussian" <- copN@param.lowbnd
upper$"Gaussian" <- copN@param.upbnd
}
if ("Frank" %in% names(combination)) {
lower$"Frank" <- copF@param.lowbnd
upper$"Frank" <- copF@param.upbnd
}
if ("Joe" %in% names(combination)) {
lower$"Joe" <- copJ@param.lowbnd
upper$"Joe" <- copJ@param.upbnd
}
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = unlist(combination),
fun = LLCG,
LB = unlist(lower),
UB = unlist(upper),
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = unlist(combination),
fun = LLCG,
LB = unlist(lower),
UB = unlist(upper),
U = unif_dist)
warnings()
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = unlist(combination),
fun = LLCG,
LB = unlist(lower),
UB = unlist(upper),
U = unif_dist)
combination
unlist(combination)
list(unlist(combination))
combination
unlist(combination)
as.list(unlist(combination))
## Non-linear constrained optimization (RSOLNP)
opt <- Rsolnp::solnp(pars = unlist(combination),
fun = LLCG,
LB = unlist(lower),
UB = unlist(upper),
U = unif_dist,
eqfun = eqfun,
eqB = c(1))
