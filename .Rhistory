weights <- round(solution(sol)[1:30], 4)[1:ncol(returns)]
return(weights)
}
weights[1, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
ret_pred <- as.data.frame(ret_pred)
weights[1, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
CVaROptimization(returns = ret_pred)
# Perform CVaR optimization to determine the optimal portfolio weights
names_vector <- names(returns[,-1])
weights <- matrix(nrow = 1, ncol = ncol(returns[,-1]))
colnames(weights) <- names_vector
# Loading ETF returns
returns <- read_csv("data_directory/etfs_rtn.csv")[-1]
# Perform CVaR optimization to determine the optimal portfolio weights
names_vector <- names(returns[,-1])
weights <- matrix(nrow = 1, ncol = ncol(returns[,-1]))
colnames(weights) <- names_vector
weights[1, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[1, names_vector[!assets_with_valid_returns]] <- 0
weights
weights[1, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred,
Alpha = 0.975,
NumAssets = 4)
weights[1, names_vector[!assets_with_valid_returns]] <- 0
weights
# Define a function to perform computations for each rolling window
process_window <- function(i) {
message(paste(i - We, "of", Wt - We))
t1 <- i - We
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
unif_dist <- ifelse(unif_dist < 0.01, 0.01, unif_dist) # avoid convergence issues
unif_dist <- ifelse(unif_dist > 0.99, 0.99, unif_dist) # avoid convergence issues
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
# Check if association_measure is NULL (i.e., an error occurred)
if (is.null(association_measure)) {
# Set weights to zero if an error occurred
weights <- rep(0, ncol(returns[,-1]))
} else {
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = association_measure,
garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
ret_pred <- as.data.frame(ret_pred)
# Perform CVaR optimization to determine the optimal portfolio weights
names_vector <- names(returns[,-1])
weights <- matrix(nrow = 1, ncol = ncol(returns[,-1]))
colnames(weights) <- names_vector
weights[1, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred,
Alpha = 0.975,
NumAssets = 8)
weights[1, names_vector[!assets_with_valid_returns]] <- 0
}
return(weights)
}
# Apply the rolling window computation to each window and store results in a list
all_weights <- purrr::map((We + 1):Wt, process_window)
# Construct portfolio and benchmarks
mixture_portfolio_1y <- RollingWindowEstimation(returns = returns,
We = 252,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
RollingWindowEstimation <- function(returns,
We = 252,
Wt = ncol(returns),
K = 10000,
Mixture = TRUE) {
# RollingWindowEstimation: Function to perform rolling window estimation of optimal portfolio weights
# Inputs:
#   returns: A data frame containing returns data with the 'date' column and each asset's returns as other columns.
#   We: Window size (default = 252) representing the number of periods for each rolling window.
#   Wt: Total number of columns in the 'returns' data frame (default is the number of columns in 'returns').
#   K: Number of iterations for copula fitting (default = 10000).
#   Mixture: Boolean flag indicating whether to use a mixture copula (default = TRUE).
# Output:
#   A data frame with 'date' and 'portfolio_return' columns, containing the portfolio returns for each rolling window.
set.seed(64)
# Define a function to perform computations for each rolling window
process_window <- function(i) {
message(paste(i - We, "of", Wt - We))
t1 <- i - We
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Define a function to compute the association measure with error handling
association_measure_with_error_handling <- function(unif_dist, Mixture, K) {
unif_dist <- ifelse(unif_dist < 0.01, 0.01, unif_dist) # avoid convergence issues
unif_dist <- ifelse(unif_dist > 0.99, 0.99, unif_dist) # avoid convergence issues
tryCatch(
{
if (Mixture) {
association_measure <- OptMixtureCopulas(unif_dist = unif_dist, K = K)
} else {
association_measure <- GaussCopula(unif_dist = unif_dist, K = K)
}
},
error = function(e) {
# In case of an error, return NULL
warning("An error occurred while computing the association measure:",
conditionMessage(e))
association_measure <- NULL
}
)
return(association_measure)
}
# Compute the association measure with error handling
association_measure <- association_measure_with_error_handling(unif_dist = fit_garch$unif_dist,
Mixture = Mixture,
K = K)
# Check if association_measure is NULL (i.e., an error occurred)
if (is.null(association_measure)) {
# Set weights to zero if an error occurred
weights <- rep(0, ncol(returns[,-1]))
} else {
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = association_measure,
garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
ret_pred <- as.data.frame(ret_pred)
# Perform CVaR optimization to determine the optimal portfolio weights
names_vector <- names(returns[,-1])
weights <- matrix(nrow = 1, ncol = ncol(returns[,-1]))
colnames(weights) <- names_vector
weights[1, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred,
Alpha = 0.975,
NumAssets = 8)
weights[1, names_vector[!assets_with_valid_returns]] <- 0
}
return(weights)
}
# Apply the rolling window computation to each window and store results in a list
all_weights <- purrr::map((We + 1):Wt, process_window)
# Combine the results into a single data frame
weights <- do.call(rbind, all_weights)
# Create a matrix with realized returns for out-of-sample period
ret_matrix_outofsample <- as.matrix(returns[(We + 1):Wt, -1])
# Replace NA values with 0
ret_matrix_outofsample[is.na(ret_matrix_outofsample)] <- 0
# Calculate portfolio returns based on the optimal weights
portfolio_returns <- rowSums(ret_matrix_outofsample * weights) - 0.0003 # minus the transaction costs
# Combine dates with portfolio returns into a data frame
result <- data.frame(date = returns[(We + 1):Wt, "date"],
portfolio_return = portfolio_returns)
return(result)
}
# Construct portfolio and benchmarks
mixture_portfolio_1y <- RollingWindowEstimation(returns = returns,
We = 252,
Wt = nrow(returns),
K = 1000,
Mixture = TRUE)
mixture_portfolio_1y <- RollingWindowEstimation(returns = returns,
We = 252,
Wt = 10,
K = 1000,
Mixture = TRUE)
# Construct portfolio and benchmarks
mixture_portfolio_1y <- RollingWindowEstimation(returns = returns,
We = 252,
Wt = 262,
K = 1000,
Mixture = TRUE)
# Convert the portfolio_returns matrix to an xts object
mixture_portfolio_1y_xts <- xts::xts(mixture_portfolio_1y[,-1],
order.by = mixture_portfolio_1y$date)
PerformanceAnalytics::chart.PerformanceSummary(mixture_portfolio_1y_xts)
PerformanceAnalytics::charts.PerformanceSummary(mixture_portfolio_1y_xts,
main = "Performance chart")
CVaROptimization <- function(returns,
Alpha = 0.975,
TargetReturn = 0,
Turnover = 0.0003,
NumAssets = 8) {
# CVaROptimization: Function to perform CVaR optimization for portfolio weights.
# Inputs:
#   returns: A data frame of asset returns.
#   Alpha: CVaR alpha level (default = 0.025).
#   NumAssets: Maximum number of assets in the portfolio (default = 8).
# Output:
#   A matrix containing the optimized portfolio weights using CVaR optimization.
cvar_objective <- function(r_mat, alpha, probs = NULL) {
x.names <- colnames(r_mat)
N <- NCOL(r_mat)
S <- NROW(r_mat)
mu <- colMeans(r_mat)
if (is.null(probs)) probs <- rep(1/S, S)
if (alpha < 0.5) alpha <- 1 - alpha
Amat <- cbind(as.matrix(r_mat),  diag(S), 1)
var.names <- c(x.names, paste0("z_cvar_aux", seq_len(S)), "gamma")
## set bounds for gamma (-Inf, Inf)
bnds <- ROI::V_bound(li = c(N + S + 1), lb = c( -Inf),
ui = c(N + S + 1), ub = c(  Inf))
constraint <- L_constraint(L = Amat, dir = rep(">=", S),
rhs = rep(0, S),
names = var.names)
objective <- L_objective(c(rep(0, N), probs/(1 - alpha), 1))
list(objective = objective, constraint = constraint, bounds = bnds)
}
budget_constraint <- function(r_mat, dir = "==", rhs = 1) {
x.names <- colnames(r_mat)
L_constraint(L = rep(1, NCOL(r_mat)),
dir = dir,  rhs = rhs, names = x.names)
}
reward_constraint <- function(r_mat, dir = ">=", rhs = TargetReturn) {
x.names <- colnames(r_mat)
L_constraint(L = colMeans(r_mat), dir = dir,
rhs = rhs, names = x.names)
}
turnover_constraint <- function(r_mat, x0 = NULL, dir = "<=", rhs = Turnover) {
x.names <- colnames(r_mat)
N <- NCOL(r_mat)
S <- NROW(r_mat)
if (is.null(x0)) x0 <- rep(1/N, N)
Amat <- cbind(diag(N), - diag(N), diag(N))
var.names <- c(x.names,
paste0("y_plus_aux", seq_len(N)),
paste0("y_minus_aux", seq_len(N)))
rbind(L_constraint(L = Amat, dir = rep("==", N), rhs = x0,
names = var.names),
L_constraint(c(rep(0, N), rep(1, N), rep(1, N) ),
dir = dir, rhs = rhs, names = var.names))
}
cardinality_constraint <- function(r_mat, dir = "<=", rhs = NumAssets) {
x.names <- colnames(r_mat)
N <- NCOL(r_mat)
Amat <- cbind(diag(N), -diag(N))
var.names <- c(x.names, paste0("z_card_aux", seq_len(N)))
cat("Variable types for z_card_aux must be set to binary.\n")
rbind(L_constraint(L = Amat, dir = rep("<=", N),
rhs = rep(0, N), names = var.names),
L_constraint(L = c(rep(0, N), rep(1, N)), dir = dir,
rhs = rhs, names = var.names))
}
tmp <- cvar_objective(returns, 0.975)
lp <- OP()
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
reward_constraint(returns),
turnover_constraint(returns),
cardinality_constraint(returns),
use.names = TRUE
)
## Variable types for z_card_aux must be set to binary.
obj <- c((tmp$objective)$L)
objective(lp) <- c(obj, double(NCOL(constraints(lp)) - length(obj)))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp) <- rep("C",  NCOL(constraints(lp) ))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp)[grep("z_card_aux", constraints(lp)$names)] <- "B"
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
(sol <- ROI_solve(lp, solver = "glpk"))
## Error in ROI_solve(lp, solver = "glpk"): objective is missing, with no default
weights <- round(solution(sol)[1:30], 4)[1:ncol(returns)]
return(weights)
}
# Construct portfolio and benchmarks
mixture_portfolio_1y <- RollingWindowEstimation(returns = returns,
We = 252,
Wt = 263,
K = 1000,
Mixture = TRUE)
mixture_portfolio_1y
returns <- as.data.frame(ret_pred)
cvar_objective <- function(r_mat, alpha, probs = NULL) {
x.names <- colnames(r_mat)
N <- NCOL(r_mat)
S <- NROW(r_mat)
mu <- colMeans(r_mat)
if (is.null(probs)) probs <- rep(1/S, S)
if (alpha < 0.5) alpha <- 1 - alpha
Amat <- cbind(as.matrix(r_mat),  diag(S), 1)
var.names <- c(x.names, paste0("z_cvar_aux", seq_len(S)), "gamma")
## set bounds for gamma (-Inf, Inf)
bnds <- ROI::V_bound(li = c(N + S + 1), lb = c( -Inf),
ui = c(N + S + 1), ub = c(  Inf))
constraint <- L_constraint(L = Amat, dir = rep(">=", S),
rhs = rep(0, S),
names = var.names)
objective <- L_objective(c(rep(0, N), probs/(1 - alpha), 1))
list(objective = objective, constraint = constraint, bounds = bnds)
}
budget_constraint <- function(r_mat, dir = "==", rhs = 1) {
x.names <- colnames(r_mat)
L_constraint(L = rep(1, NCOL(r_mat)),
dir = dir,  rhs = rhs, names = x.names)
}
reward_constraint <- function(r_mat, dir = ">=", rhs = TargetReturn) {
x.names <- colnames(r_mat)
L_constraint(L = colMeans(r_mat), dir = dir,
rhs = rhs, names = x.names)
}
turnover_constraint <- function(r_mat, x0 = NULL, dir = "<=", rhs = Turnover) {
x.names <- colnames(r_mat)
N <- NCOL(r_mat)
S <- NROW(r_mat)
if (is.null(x0)) x0 <- rep(1/N, N)
Amat <- cbind(diag(N), - diag(N), diag(N))
var.names <- c(x.names,
paste0("y_plus_aux", seq_len(N)),
paste0("y_minus_aux", seq_len(N)))
rbind(L_constraint(L = Amat, dir = rep("==", N), rhs = x0,
names = var.names),
L_constraint(c(rep(0, N), rep(1, N), rep(1, N) ),
dir = dir, rhs = rhs, names = var.names))
}
cardinality_constraint <- function(r_mat, dir = "<=", rhs = NumAssets) {
x.names <- colnames(r_mat)
N <- NCOL(r_mat)
Amat <- cbind(diag(N), -diag(N))
var.names <- c(x.names, paste0("z_card_aux", seq_len(N)))
cat("Variable types for z_card_aux must be set to binary.\n")
rbind(L_constraint(L = Amat, dir = rep("<=", N),
rhs = rep(0, N), names = var.names),
L_constraint(L = c(rep(0, N), rep(1, N)), dir = dir,
rhs = rhs, names = var.names))
}
tmp <- cvar_objective(returns, 0.975)
lp <- OP()
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
reward_constraint(returns),
turnover_constraint(returns),
cardinality_constraint(returns),
use.names = TRUE
)
TargetReturn = 0
Turnover = 0.0003
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
reward_constraint(returns),
turnover_constraint(returns),
cardinality_constraint(returns),
use.names = TRUE
)
## Variable types for z_card_aux must be set to binary.
obj <- c((tmp$objective)$L)
objective(lp) <- c(obj, double(NCOL(constraints(lp)) - length(obj)))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp) <- rep("C",  NCOL(constraints(lp) ))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp)[grep("z_card_aux", constraints(lp)$names)] <- "B"
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
(sol <- ROI_solve(lp, solver = "glpk"))
## Error in ROI_solve(lp, solver = "glpk"): objective is missing, with no default
weights <- round(solution(sol)[1:30], 4)[1:ncol(returns)]
weights
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
reward_constraint(returns),
#turnover_constraint(returns),
cardinality_constraint(returns),
use.names = TRUE
)
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
reward_constraint(returns),
turnover_constraint(returns),
cardinality_constraint(returns),
use.names = TRUE
)
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
#reward_constraint(returns),
turnover_constraint(returns),
cardinality_constraint(returns),
use.names = TRUE
)
## Variable types for z_card_aux must be set to binary.
obj <- c((tmp$objective)$L)
objective(lp) <- c(obj, double(NCOL(constraints(lp)) - length(obj)))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp) <- rep("C",  NCOL(constraints(lp) ))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp)[grep("z_card_aux", constraints(lp)$names)] <- "B"
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
(sol <- ROI_solve(lp, solver = "glpk"))
## Error in ROI_solve(lp, solver = "glpk"): objective is missing, with no default
weights <- round(solution(sol)[1:30], 4)[1:ncol(returns)]
weights
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
#reward_constraint(returns),
#turnover_constraint(returns),
cardinality_constraint(returns),
use.names = TRUE
)
tmp <- cvar_objective(returns, 0.975)
lp <- OP()
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
#reward_constraint(returns),
#turnover_constraint(returns),
cardinality_constraint(returns),
use.names = TRUE
)
## Variable types for z_card_aux must be set to binary.
obj <- c((tmp$objective)$L)
objective(lp) <- c(obj, double(NCOL(constraints(lp)) - length(obj)))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp) <- rep("C",  NCOL(constraints(lp) ))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp)[grep("z_card_aux", constraints(lp)$names)] <- "B"
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
(sol <- ROI_solve(lp, solver = "glpk"))
## Error in ROI_solve(lp, solver = "glpk"): objective is missing, with no default
weights <- round(solution(sol)[1:30], 4)[1:ncol(returns)]
weights
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
#reward_constraint(returns),
turnover_constraint(returns),
cardinality_constraint(returns, dir = "<=", rhs = NumAssets),
use.names = TRUE
)
tmp <- cvar_objective(returns, 0.975)
lp <- OP()
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
#reward_constraint(returns),
turnover_constraint(returns),
cardinality_constraint(returns, dir = "<=", rhs = NumAssets),
use.names = TRUE
)
## Variable types for z_card_aux must be set to binary.
obj <- c((tmp$objective)$L)
objective(lp) <- c(obj, double(NCOL(constraints(lp)) - length(obj)))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp) <- rep("C",  NCOL(constraints(lp) ))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp)[grep("z_card_aux", constraints(lp)$names)] <- "B"
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
(sol <- ROI_solve(lp, solver = "glpk"))
## Error in ROI_solve(lp, solver = "glpk"): objective is missing, with no default
weights <- round(solution(sol)[1:30], 4)[1:ncol(returns)]
weights
tmp <- cvar_objective(returns, 0.975)
lp <- OP()
constraints(lp) <- rbind(
tmp$constraint,
budget_constraint(returns),
reward_constraint(returns),
#turnover_constraint(returns),
cardinality_constraint(returns, dir = "<=", rhs = NumAssets),
use.names = TRUE
)
## Variable types for z_card_aux must be set to binary.
obj <- c((tmp$objective)$L)
objective(lp) <- c(obj, double(NCOL(constraints(lp)) - length(obj)))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp) <- rep("C",  NCOL(constraints(lp) ))
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
types(lp)[grep("z_card_aux", constraints(lp)$names)] <- "B"
## Error in (function (classes, fdef, mtable) : unable to find an inherited method for function 'constraints' for signature '"OP"'
(sol <- ROI_solve(lp, solver = "glpk"))
## Error in ROI_solve(lp, solver = "glpk"): objective is missing, with no default
weights <- round(solution(sol)[1:30], 4)[1:ncol(returns)]
return(weights)
weights
