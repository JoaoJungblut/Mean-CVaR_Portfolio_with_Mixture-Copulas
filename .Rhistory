PredictGarch <- function(returns, sigma, zsim, garch_coef) {
# Initialize matrices to store predicted values
ret_pred <- mean_pred <- sigma_pred <- matrix(nrow = nrow(zsim), ncol = ncol(returns))
for (j in 1:ncol(returns)) {
# Get the last observed return and sigma
ret_t <- as.numeric(returns[nrow(returns), j])
sigma_t <- sigma[nrow(sigma), j]
# Forecasting at t = 1
sigma_pred[1, j] <- sqrt(garch_coef[[j]][7] +  # omega
garch_coef[[j]][3] * (ret_t)^2 +  # alpha1
garch_coef[[j]][4] * (sigma_t)^2)  # beta1
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2] * ret_t  # mu and ar1
ret_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j] * zsim[1, j]
# Forecasting for t > 1
for (i in 2:nrow(zsim)) {
sigma_pred[i, j] <- sqrt(garch_coef[[j]][7] +  # omega
garch_coef[[j]][3] * (ret_pred[(i - 1), j])^2 +  # alpha1
garch_coef[[j]][4] * (sigma_pred[(i - 1), j])^2)  # beta1
mean_pred[i, j] <- garch_coef[[j]][1] + garch_coef[[j]][2] * ret_pred[(i - 1), j]  # mu and ar1
ret_pred[i, j] <- mean_pred[i, j] + sigma_pred[i, j] * zsim[i, j]
}
}
# Create a list to store the predicted values
result <- list(sigma_pred = sigma_pred,
mean_pred = mean_pred,
ret_pred = ret_pred)
return(result)
}
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)$ret_pred
ret_pred
for (i in 2:length(index_vector)){
print(i)
# Establishing window interval in-sample
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist, K = K)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)$ret_pred
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Establishing window interval in-sample
t3 <- t1 + We
t4 <- min(nrow(returns), t2+We)
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[t3:t4,-1])
ret_matrix_outofsample[, names_vector[!assets_with_valid_returns]] <- 0
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[t3:t4,] <- RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = rbind(weights[i,]))
}
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns[1:Wt,]$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts)
zsim
ret_pred
ret_pred*100
fit_garch$sigma
weights
portfolio_returns
view(portfolio_returns)
weights
i=24
rbind(weights[i,])
sum(weights[i,])
ret_matrix_outofsample - 0.0003
sum(ret_matrix_outofsample - 0.0003)
sum(ret_matrix_outofsample[,3] - 0.0003)
RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = rbind(weights[i,]))
sum(RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = rbind(weights[i,])))
rbind(weights[i,])
weights[i,]
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[t3:t4,] <- RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = cbind(weights[i,]))
ret_matrix_outofsample[,15]%*%weights[i,15]
ret_matrix_outofsample[,15]%*%t(weights[i,15])
sum(ret_matrix_outofsample[,15]%*%t(weights[i,15]))
sum(portfolio_returns)
sum(portfolio_returns[1:500,])
sum(portfolio_returns[1:750,])
sum(portfolio_returns[1:1000,])
min(portfolio_returns[1:1000,])
sum(portfolio_returns[1000:1500,])
# Define the list of stock tickers and the start date for data retrieval
tickers <- c("PETR4.SA", "VALE3.SA", "ITUB4.SA", "BBAS3.SA", "ABEV3.SA",
"BBDC4.SA", "GRND3.SA", "SMTO3.SA", "SLCE3.SA", "VIVT3.SA")
start_date <- "2000-01-01"
# Retrieve the stock returns for the given tickers and start date
returns <- GetReturns(tickers = tickers, start_date = start_date)
# setting R project environment
my_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my_dir)
# cleaning variables and graphs
rm(list=ls())
graphics.off()
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(tidyquant)     # Financial data analysis
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
library(PerformanceAnalytics) # Performance metrics
library(xts) # Time series object
# Importing modules
source("data_preprocessing.R")
source("garch_estimate.R")
source("copula_estimate.R")
source("portfolio_optimization.R")
source("performance_metrics.R")
# Define the list of stock tickers and the start date for data retrieval
tickers <- c("PETR4.SA", "VALE3.SA", "ITUB4.SA", "BBAS3.SA", "ABEV3.SA",
"BBDC4.SA", "GRND3.SA", "SMTO3.SA", "SLCE3.SA", "VIVT3.SA")
start_date <- "2000-01-01"
# Retrieve the stock returns for the given tickers and start date
returns <- GetReturns(tickers = tickers, start_date = start_date)
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
We <- 252 # Window size for GARCH estimation
Wt <- nrow(returns) # Total size of window
K <- 10000 # Number of simulations
index_vector <- seq(1, Wt, by = We)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
weights <- matrix(nrow = length(index_vector), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1,] <-  0 # Initialize the first row of the weights matrix as all zeros
portfolio_returns <- matrix(nrow = Wt, ncol = 1)  # Matrix to store portfolio returns
portfolio_returns[1:We, ] <- 0  # Initialize the first K rows as zero
set.seed(53)
PredictGarch <- function(returns, sigma, zsim, garch_coef) {
# Initialize matrices to store predicted values
ret_pred <- mean_pred <- sigma_pred <- matrix(nrow = nrow(zsim), ncol = ncol(returns))
for (j in 1:ncol(returns)) {
# Get the last observed return and sigma
ret_t <- as.numeric(returns[nrow(returns), j])
sigma_t <- sigma[nrow(sigma), j]
# Forecasting at t = 1
sigma_pred[1, j] <- sqrt(garch_coef[[j]][7] +  # omega
garch_coef[[j]][3] * (ret_t)^2 +  # alpha1
garch_coef[[j]][4] * (sigma_t)^2)  # beta1
mean_pred[1, j] <- garch_coef[[j]][1] + garch_coef[[j]][2] * ret_t  # mu and ar1
ret_pred[1, j] <- mean_pred[1, j] + sigma_pred[1, j] * zsim[1, j]
# Forecasting for t > 1
for (i in 2:nrow(zsim)) {
sigma_pred[i, j] <- sqrt(garch_coef[[j]][7] +  # omega
garch_coef[[j]][3] * (ret_pred[(i - 1), j])^2 +  # alpha1
garch_coef[[j]][4] * (sigma_pred[(i - 1), j])^2)  # beta1
mean_pred[i, j] <- garch_coef[[j]][1] + garch_coef[[j]][2] * ret_pred[(i - 1), j]  # mu and ar1
ret_pred[i, j] <- mean_pred[i, j] + sigma_pred[i, j] * zsim[i, j]
}
}
# Create a list to store the predicted values
result <- list(sigma_pred = sigma_pred,
mean_pred = mean_pred,
ret_pred = ret_pred)
return(result)
}
for (i in 2:length(index_vector)){
print(i)
# Establishing window interval in-sample
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist, K = K)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)$ret_pred
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Establishing window interval in-sample
t3 <- t1 + We
t4 <- min(nrow(returns), t2+We)
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[t3:t4,-1])
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[t3:t4,] <- RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = rbind(weights[i,]))
}
returns
}
# Importing data and calculating returns
GetReturns <- function(tickers, start_date) {
data <- tidyquant::tq_get(tickers, from = start_date) %>%
dplyr::select("date", "symbol", "adjusted") %>%
dplyr::group_by(symbol) %>%
dplyr::mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
dplyr::ungroup() %>%
dplyr::select(-adjusted) %>%
tidyr::spread(key = symbol, value = return) %>%
dplyr::mutate(dplyr::across(where(is.numeric)))
return(data)
}
# Define the list of stock tickers and the start date for data retrieval
tickers <- c("PETR4.SA", "VALE3.SA", "ITUB4.SA", "BBAS3.SA", "ABEV3.SA",
"BBDC4.SA", "GRND3.SA", "SMTO3.SA", "SLCE3.SA", "VIVT3.SA")
start_date <- "2000-01-01"
# Retrieve the stock returns for the given tickers and start date
returns <- GetReturns(tickers = tickers, start_date = start_date)
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
We <- 252 # Window size for GARCH estimation
Wt <- nrow(returns) # Total size of window
K <- 10000 # Number of simulations
index_vector <- seq(1, Wt, by = We)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
weights <- matrix(nrow = length(index_vector), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1,] <-  0 # Initialize the first row of the weights matrix as all zeros
portfolio_returns <- matrix(nrow = Wt, ncol = 1)  # Matrix to store portfolio returns
portfolio_returns[1:We, ] <- 0  # Initialize the first K rows as zero
set.seed(53)
for (i in 2:length(index_vector)){
print(i)
# Establishing window interval in-sample
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist, K = K)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)$ret_pred
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Establishing window interval in-sample
t3 <- t1 + We
t4 <- min(nrow(returns), t2+We)
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[t3:t4,-1])
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[t3:t4,] <- RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = rbind(weights[i,]))
}
returns
# Establishing window interval in-sample
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
i=2
# Establishing window interval in-sample
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
ret_matrix_insample
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
ret_matrix_insample
assets_with_valid_returns
start_date <- "2010-01-01"
# Retrieve the stock returns for the given tickers and start date
returns <- GetReturns(tickers = tickers, start_date = start_date)
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
We <- 252 # Window size for GARCH estimation
Wt <- nrow(returns) # Total size of window
K <- 10000 # Number of simulations
index_vector <- seq(1, Wt, by = We)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
weights <- matrix(nrow = length(index_vector), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1,] <-  0 # Initialize the first row of the weights matrix as all zeros
portfolio_returns <- matrix(nrow = Wt, ncol = 1)  # Matrix to store portfolio returns
portfolio_returns[1:We, ] <- 0  # Initialize the first K rows as zero
set.seed(53)
for (i in 2:length(index_vector)){
print(i)
# Establishing window interval in-sample
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist, K = K)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)$ret_pred
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Establishing window interval in-sample
t3 <- t1 + We
t4 <- min(nrow(returns), t2+We)
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[t3:t4,-1])
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[t3:t4,] <- RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = rbind(weights[i,]))
}
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Importing data and calculating returns
GetReturns <- function(tickers, start_date) {
data <- tidyquant::tq_get(tickers, from = start_date) %>%
dplyr::select("date", "symbol", "adjusted") %>%
dplyr::group_by(symbol) %>%
dplyr::mutate(return = log(adjusted) - log(dplyr::lag(adjusted))) %>%
dplyr::ungroup() %>%
dplyr::select(-adjusted) %>%
stats::na.omit() %>%
tidyr::spread(key = symbol, value = return) %>%
dplyr::mutate(dplyr::across(where(is.numeric)))
return(data)
}
# Define the list of stock tickers and the start date for data retrieval
tickers <- c("PETR4.SA", "VALE3.SA", "ITUB4.SA", "BBAS3.SA", "ABEV3.SA",
"BBDC4.SA", "GRND3.SA", "SMTO3.SA", "SLCE3.SA", "VIVT3.SA")
start_date <- "2010-01-01"
start_date <- "2000-01-01"
# Retrieve the stock returns for the given tickers and start date
returns <- GetReturns(tickers = tickers, start_date = start_date)
returns
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
ret_matrix_insample
for (i in 2:length(index_vector)){
print(i)
# Establishing window interval in-sample
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist, K = K)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)$ret_pred
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Establishing window interval in-sample
t3 <- t1 + We
t4 <- min(nrow(returns), t2+We)
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[t3:t4,-1])
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[t3:t4,] <- RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = rbind(weights[i,]))
}
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns[1:Wt,]$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts)
# Importing log-returns data file
returns <- read_csv("data_directory/etfs_rtn.csv")
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
We <- 252 # Window size for GARCH estimation
Wt <- nrow(returns) # Total size of window
K <- 10000 # Number of simulations
index_vector <- seq(1, Wt, by = We)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
weights <- matrix(nrow = length(index_vector), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1,] <-  0 # Initialize the first row of the weights matrix as all zeros
portfolio_returns <- matrix(nrow = Wt, ncol = 1)  # Matrix to store portfolio returns
portfolio_returns[1:We, ] <- 0  # Initialize the first K rows as zero
set.seed(123)
for (i in 2:length(index_vector)){
print(i)
# Establishing window interval in-sample
t1 <- index_vector[i - 1]
t2 <- index_vector[i] - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist, K = K)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)$ret_pred
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Establishing window interval in-sample
t3 <- t1 + We
t4 <- min(nrow(returns), t2+We)
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[t3:t4,-1])
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[t3:t4,] <- RetPortfolio(returns = ret_matrix_outofsample - 0.0003, # minus the transaction costs
weights = rbind(weights[i,]))
}
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns[1:Wt,]$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts)
