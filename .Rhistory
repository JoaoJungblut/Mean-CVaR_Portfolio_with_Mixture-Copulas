geom_bar(aes(x = date, y = soma),
stat = "identity", fill = "ForestGreen", color = "Black") +
geom_line(aes(x = date, y = media),
stat = "identity", color = "Orange", size = 2) +
theme_bw() +
labs(x = "Meses",
y = "Reais")
tabela <- summary(base$valor)
tabela
summary(base$valor*100)
library(tidyverse)
library(readxl)
PerformanceAnalytics::charts.PerformanceSummary
install.packages("languageserver")
install.packages("radian")
# setting R project environment
my_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my_dir)
# cleaning variables and graphs
rm(list=ls())
graphics.off()
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(tidyquant)     # Financial data analysis
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
library(PerformanceAnalytics) # Performance metrics
library(xts) # Time series object
# Importing modules
source("data_preprocessing.R")
source("garch_estimate.R")
source("copula_estimate.R")
source("portfolio_optimization.R")
source("performance_metrics.R")
# Retrieve the stock returns for the given tickers and start date
#returns <- GetReturns(tickers = tickers, start_date = start_date)
#returns <- read_csv("data_directory/log_rtn.csv")
returns <- read_csv("data_directory/etfs_rtn.csv")
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
K <- 252                 # Window size for GARCH estimation
index_vector <- seq(1, nrow(returns), by = K)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
weights <- matrix(nrow = length(index_vector), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1,] <-  0 # Initialize the first row of the weights matrix as all zeros
portfolio_returns <- matrix(nrow = nrow(returns), ncol = 1)  # Matrix to store portfolio returns
portfolio_returns[1:K, ] <- 0  # Initialize the first K rows as zero
weights <- matrix(nrow = nrow(returns), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1:K,] <-  0 # Initialize the first row of the weights matrix as all zeros
for (i in (K + 1):nrow(returns)){
print(paste(i - K, "of", nrow(returns) - K))
# Establishing window interval in-sample
t1 <- i - K
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- try(OptMixtureCopulas(unif_dist = fit_garch$unif_dist), silent=TRUE)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[i, -1])
ret_matrix_outofsample[, names_vector[!assets_with_valid_returns]] <- 0
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[i,] <- RetPortfolio(returns = ret_matrix_outofsample,
weights = rbind(weights[i,])) - 0.0003
}
portfolio_returns
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts)
# setting R project environment
my_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my_dir)
# cleaning variables and graphs
rm(list=ls())
graphics.off()
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(tidyquant)     # Financial data analysis
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
library(PerformanceAnalytics) # Performance metrics
library(xts) # Time series object
# Importing modules
source("data_preprocessing.R")
source("garch_estimate.R")
source("copula_estimate.R")
source("portfolio_optimization.R")
source("performance_metrics.R")
# Retrieve the stock returns for the given tickers and start date
#returns <- GetReturns(tickers = tickers, start_date = start_date)
#returns <- read_csv("data_directory/log_rtn.csv")
returns <- read_csv("data_directory/etfs_rtn.csv")
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
K <- 252                 # Window size for GARCH estimation
index_vector <- seq(1, nrow(returns), by = K)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
weights <- matrix(nrow = length(index_vector), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1,] <-  0 # Initialize the first row of the weights matrix as all zeros
portfolio_returns <- matrix(nrow = nrow(returns), ncol = 1)  # Matrix to store portfolio returns
portfolio_returns[1:K, ] <- 0  # Initialize the first K rows as zero
weights <- matrix(nrow = nrow(returns), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1:K,] <-  0 # Initialize the first row of the weights matrix as all zeros
for (i in (K + 1):200){
print(paste(i - K, "of", nrow(returns) - K))
# Establishing window interval in-sample
t1 <- i - K
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[i, -1])
ret_matrix_outofsample[, names_vector[!assets_with_valid_returns]] <- 0
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[i,] <- RetPortfolio(returns = ret_matrix_outofsample,
weights = rbind(weights[i,])) - 0.0003
}
for (i in (K + 1):452){
print(paste(i - K, "of", nrow(returns) - K))
# Establishing window interval in-sample
t1 <- i - K
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[i, -1])
ret_matrix_outofsample[, names_vector[!assets_with_valid_returns]] <- 0
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[i,] <- RetPortfolio(returns = ret_matrix_outofsample,
weights = rbind(weights[i,])) - 0.0003
}
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts)
for (i in (K + 1):600){
print(paste(i - K, "of", nrow(returns) - K))
# Establishing window interval in-sample
t1 <- i - K
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[i, -1])
ret_matrix_outofsample[, names_vector[!assets_with_valid_returns]] <- 0
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[i,] <- RetPortfolio(returns = ret_matrix_outofsample,
weights = rbind(weights[i,])) - 0.0003 # minus the transaction costs
}
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts)
# Rolling window estimation
for (i in (K + 1):1000){
print(paste(i - K, "of", nrow(returns) - K))
# Establishing window interval in-sample
t1 <- i - K
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[i, -1])
ret_matrix_outofsample[, names_vector[!assets_with_valid_returns]] <- 0
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[i,] <- RetPortfolio(returns = ret_matrix_outofsample,
weights = rbind(weights[i,])) - 0.0003 # minus the transaction costs
}
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns[1:1000,], order.by = returns$date)
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns[1:748,], order.by = returns$date)
portfolio_returns[1:748,]
portfolio_returns
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts[1:748,])
# setting R project environment
my_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my_dir)
# cleaning variables and graphs
rm(list=ls())
graphics.off()
library(tidyquant)     # Financial data analysis
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
library(PerformanceAnalytics) # Performance metrics
library(xts) # Time series object
# Importing modules
source("data_preprocessing.R")
source("garch_estimate.R")
source("copula_estimate.R")
source("portfolio_optimization.R")
source("performance_metrics.R")
# Define the list of stock tickers and the start date for data retrieval
returns <- read_csv("data_directory/etfs_rtn.csv")
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
K <- 252                 # Window size for GARCH estimation
index_vector <- seq(1, nrow(returns), by = K)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
weights <- matrix(nrow = nrow(returns), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1:K,] <-  0 # Initialize the first row of the weights matrix as all zeros
portfolio_returns <- matrix(nrow = nrow(returns), ncol = 1)  # Matrix to store portfolio returns
portfolio_returns[1:K, ] <- 0  # Initialize the first K rows as zero
# Rolling window estimation
for (i in (K + 1):nrow(returns)){
print(paste(i - K, "of", nrow(returns) - K))
# Establishing window interval in-sample
t1 <- i - K
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[i, -1])
ret_matrix_outofsample[, names_vector[!assets_with_valid_returns]] <- 0
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[i,] <- RetPortfolio(returns = ret_matrix_outofsample,
weights = rbind(weights[i,])) - 0.0003 # minus the transaction costs
}
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts)
# Define the list of stock tickers and the start date for data retrieval
tickers <- c("PETR4.SA", "VALE3.SA", "ITUB4.SA", "BBAS3.SA", "ABEV3.SA",
"BBDC4.SA", "GRND3.SA", "SMTO3.SA", "SLCE3.SA", "VIVT3.SA")
start_date <- "2010-01-01"
#Retrieve the stock returns for the given tickers and start date
returns <- GetReturns(tickers = tickers, start_date = start_date)
# setting R project environment
my_dir <- dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(my_dir)
# cleaning variables and graphs
rm(list=ls())
graphics.off()
# Load required packages
library(tidyverse)     # Data manipulation and visualization
library(tidyquant)     # Financial data analysis
library(rugarch)       # Univariate GARCH modeling
library(fGarch)        # Multivariate GARCH modeling
library(copula)        # Copula modeling
library(Rsolnp)        # Nonlinear optimization
library(fPortfolio)    # Portfolio optimization
library(PerformanceAnalytics) # Performance metrics
library(xts) # Time series object
# Importing modules
source("data_preprocessing.R")
source("garch_estimate.R")
source("copula_estimate.R")
source("portfolio_optimization.R")
source("performance_metrics.R")
# Define the list of stock tickers and the start date for data retrieval
tickers <- c("PETR4.SA", "VALE3.SA", "ITUB4.SA", "BBAS3.SA", "ABEV3.SA",
"BBDC4.SA", "GRND3.SA", "SMTO3.SA", "SLCE3.SA", "VIVT3.SA")
start_date <- "2010-01-01"
#Retrieve the stock returns for the given tickers and start date
returns <- GetReturns(tickers = tickers, start_date = start_date)
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
K <- 252                 # Window size for GARCH estimation
index_vector <- seq(1, nrow(returns), by = K)  # Index vector for rolling optimization
returns
# Creating auxiliary matrices and list
N <- base::ncol(returns) - 1   # Number of assets
K <- 252                 # Window size for GARCH estimation
index_vector <- seq(1, nrow(returns), by = K)  # Index vector for rolling optimization
names_vector <- names(returns)[-1]   # Asset names for reference
weights <- matrix(nrow = nrow(returns), ncol = N) # Create a matrix to store the weights for each asset in the portfolio
colnames(weights) <- names_vector # Set the column names of the weights matrix as the asset names
weights[1:K,] <-  0 # Initialize the first row of the weights matrix as all zeros
portfolio_returns <- matrix(nrow = nrow(returns), ncol = 1)  # Matrix to store portfolio returns
portfolio_returns[1:K, ] <- 0  # Initialize the first K rows as zero
# Rolling window estimation
for (i in (K + 1):nrow(returns)){
print(paste(i - K, "of", nrow(returns) - K))
# Establishing window interval in-sample
t1 <- i - K
t2 <- i - 1
# Convert the in-sample returns data to a matrix format
ret_matrix_insample <- as.matrix(returns[t1:t2, -1])
# Create a logical vector indicating if each asset has sufficient data
assets_with_valid_returns <- !colMeans(is.na(ret_matrix_insample[,]))
# Subset the returns matrix and asset names based on assets with sufficient data
ret_matrix_insample <- ret_matrix_insample[, assets_with_valid_returns]
# Fit the GARCH model to the returns data
fit_garch <- FitGarch(returns = ret_matrix_insample)
# Optimize the mixture of copulas using the uniform distribution from the GARCH model
copulas_mixture <- OptMixtureCopulas(unif_dist = fit_garch$unif_dist)
# Compute simulated standardized residuals using the optimized copula mixture and GARCH coefficients
zsim <- ComputeZSim(copula_mixture = copulas_mixture, garch_coef = fit_garch$garch_coef)
# Predict future returns using the GARCH model, simulated residuals, and volatility estimates
ret_pred <- PredictGarch(returns = ret_matrix_insample,
sigma = fit_garch$sigma,
zsim = zsim,
garch_coef = fit_garch$garch_coef)
# Perform CVaR optimization to determine the optimal portfolio weights
weights[i, names_vector[assets_with_valid_returns]] <- CVaROptimization(returns = ret_pred)
weights[i, names_vector[!assets_with_valid_returns]] <- 0
# Convert the realized returns data to a matrix format
ret_matrix_outofsample <- as.matrix(returns[i, -1])
ret_matrix_outofsample[, names_vector[!assets_with_valid_returns]] <- 0
# Calculate the portfolio returns based on the optimal weights
portfolio_returns[i,] <- RetPortfolio(returns = ret_matrix_outofsample,
weights = rbind(weights[i,])) - 0.0003 # minus the transaction costs
}
# Convert the portfolio_returns matrix to an xts object
portfolio_returns_xts <- xts::xts(portfolio_returns, order.by = returns$date)
# Calculate Sharpe ratio
sharpe_ratio <- PerformanceAnalytics::SharpeRatio.annualized(portfolio_returns_xts)
# Calculate annualized return
annualized_return <- PerformanceAnalytics::Return.annualized(portfolio_returns_xts)
# Calculate cumulative return
cumulative_return <- PerformanceAnalytics::Return.cumulative(portfolio_returns_xts)
# Calculate drawdowns
drawdown <- PerformanceAnalytics::maxDrawdown(portfolio_returns_xts)
# Print the calculated metrics
print(sharpe_ratio)
print(annualized_return)
print(cumulative_return)
print(drawdown)
# Generate graph
PerformanceAnalytics::charts.PerformanceSummary(portfolio_returns_xts)
